# Graphics in R {#graphics_r}

For many people, one of their favourite uses of R is in making figures. These can either take the form of a quick dirty plot to allow you to get a feel for what's going on in your dataset, or fancier/more complex figures to use in a publication or report. This process is often as close as many analysts/scientists get to having a professional creative side (at least that's true for me), and it's something which those folks take great pride in.

As stated in the introduction, one of the many reasons for the rise in the popularity of R is due to its ability to produce publication standard figures (as well as those quick and dirty figures - which are the type you and I and everyone else will produce most of). Not only can R users make figures well suited for publication, but producing figures in R allows for lots of customisation, in turn allowing users to create their own particular styles and brands of figures (well beyond the beyond cookie-cutter styles in more traditional click and point programs). Because of this inherent flexibility when producing figures, the data visualisation side of R and supporting packages has grown substantially over the years.

In this chapter, we will focus on creating figures through using a specialised package called `ggplot2`.

Before we get going with making some plots of the gg variety, how about a quick little history of one of the most commonly used packages in R? `ggplot2` was based on a book called _Grammar of Graphics_ (hence the gg in `ggplot2`) by Leland Wilkinson [yours for only £100 or so](https://www.springer.com/gp/book/9780387245447). But before you spend £100 see [here](https://www.jstatsoft.org/article/view/v017b03/v17b03.pdf) for an interesting summary of Wilkinson's book. 

Briefly, Wilkinson's idea (one of them anyway) in _grammar of graphics_ was that figures can be broken down into constituent parts, such as layers (more on this later). While Wilkinson would eventually go on to become vice-president of SPSS, his (and his co-author's) ideas would, never-the-less, make their way into R via `ggplot2`. 

In 2007 `ggplot2`was officially released by Hadley Wickham. By 2017 the package was said to have been downloaded 10,000,000 times. `ggplot2` now has many secondary packages that use it either as a foundation for expanding on or for interfacing with (some statistical packages now have accompanying `ggplot2` interfaces for producing figures).

It is important to note here that `ggplot2` is not required to make "fancy" figures. If you'd prefer to use base R then go ahead. Exactly equivalent figures are possible in base R. The difference between`ggplot2` and base is to do with how you _get_ to the end product rather than any differences in the end product itself. This is, never-the-less, a common belief almost certainly due to the fact that making a moderately attractive figure is easier to do with `ggplot2` as many decisions are made for the user, without you necessarily even knowing that a decision was ever made!

With that in mind, let's get started making some figures.

\

## Beginning at the end

The approach I'll use in this chapter will be to start off by showing you a figure which I reckon is at a standard that you could use in a poster or presentation. Using that as the aim, we will then work towards it step-by-step. You should not view this final figure as any sort of holy grail. For instance, you would be very unlikely to use this in a publication (you'd be much more likely to use some results of your hard earned-analysis). Regardless, this "final figure" is, and will only ever be, a reflection of what my personal preferences are. As with anything subjective, you may well disagree, and to some extent I hope you do. Much better that we all have slightly (or grossly) different views on what a good figure is - otherwise we may as well go back to using cookie-cutter figures.

So what is the figure we're going to make together?

```{r final figure - start, echo = FALSE, out.width = "75%", fig.align = "center", warning = FALSE}
flower <- read.csv("data/flower.csv")
library(ggplot2)

flower$nitrogen2 <- factor(flower$nitrogen, levels = c("high", "medium", "low"))

theme_deon <- function(base_size = 20, base_family = "", base_line_size = base_size/22, base_rect_size = base_size/22) {         
  theme( 
    axis.title = element_text(size = 20),                               
    axis.text.x = element_text(size = 10),                              
    axis.text.y = element_text(size = 10),                              
    plot.caption = element_text(size = 10, face = "italic"),            
    panel.background = element_rect(fill="white"),                      
    axis.line = element_line(size = 1, colour = "black"),
    strip.background =element_rect(fill = "black"),
    panel.border = element_rect(colour = "black", fill=NA, size=0.5),
		strip.text = element_text(colour = "white"),
		legend.key=element_blank()
  )
}

final_figure <- ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point(aes(colour = nitrogen2, shape = nitrogen2), size = 2, alpha = 0.6) +
	geom_smooth(aes(colour = "Overall", shape = "Overall"), method = "lm", se = F, linetype = 2, alpha = 0.6) +
	geom_smooth(aes(colour = nitrogen2), method = "lm", se = F, size = 1.2) +
	facet_grid(block~treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = "black", linetype = 3) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4", "black"),
											labels = c("High", "Medium", "Low", "Overall")) +
	scale_shape_manual(values = c(15,17,19,21),
										 labels = c("High", "Medium", "Low", "Overall")) +
	theme_deon()

final_figure
```

Before we go further, let's take a second and talk about what this figure is literally showing. On the y axes of the four plots we have the area of the shoot and the x axes we have the weight of a flower. Each column shows the two treatments of the dataset (whether the tip of the flower was cut or not) and the two rows show which block of the greenhouse the plants were grown in (block 1 and block 2). The thin dotted line shows the mean shoot area regardless of the weight of the flowers, the treatment or the block. For our purposes, we won't worry about the biology here (though you should absolutely care deeply about that in your own data); all we care about here is that we are giving the audience lots of information in a relatively readable format.

## The start of the end

The first step in producing a `ggplot()` is the easiest! We just need to install and then load the package. Use the skills you learnt in Chapter 1.5 to install and load the package. Note that although I (and pretty much everyone) refer to the package as `ggplot`, it's proper name is `ggplot2`.

```{r installing & loading ggplot}
library(ggplot2)
```

With that taken care of, let's make our first `ggplot()`!

### The purest of ggplots

During the R course this book is based on, the students are asked at one point to shout out all of the functions they have either learnt in the course or heard of/used before. At this point in the course we have not touched on `ggplot2`, but one year a student shouted out `ggplot()`. When asked what the `ggplot()` function does, they said that it makes a `ggplot`. This makes complete and utter sense. So let's make a `ggplot` now:

```{r pure ggplot, out.width = "75%", fig.align = "center"}
ggplot()
```

And here we have it. A fully formed, perfect `ggplot`. We may have a small issue though. Some puritan data visualisers/plotists/figurines make the claim that figures should include some form of information beyond a light grey background. As loathe as I am to agree with purists, I will do so here. We really should include some data. To do so, we need some data.

We'll keep using the flower dataset that you used in the earlier chapters. Let's have a quick reminder of what the data looked like.

```{r str of flower}
str(flower)
```

We know from the "final figure" that we want shootarea on the y axis and weight on the x axis. To do so in `ggplot2` we need to make use of the `aes()` function and also fulfill the `data =` argument. `aes` is short for aesthetics, and it's the function we use to specify what we want displayed in the figure. Let's try it now:

```{r ggplot with xy axis, out.width = "75%", fig.align = "center"}
# Including aesthetics for x and y axes as well as specifying the dataset
ggplot(aes(x = weight, y = shootarea), data = flower) 
```

That's already much better. At least it's no longer a blank grey canvas. We've now told `ggplot2` what we want as our x and y axes as well as where to find that data. But what's missing here is where we tell `ggplot2` _how_ to display that data. This is now the time to introduce you to "geoms" or geometric objects. Geoms are the way that `ggplot2` displays information. For instance `geom_point()` tells `ggplot2` that you want the information to be displayed as points (making scatterplots possible for example). Given that the "final figure" uses points, this is clearly the appropriate geom to use here.

Before we can do that, we need to talk about the coding structure used by `ggplot2`. The analogy that I and many others use is to say that making a figure in `ggplot2` is much like painting. What we've done in the above code is making our "canvas". Now we are going to add sequential layers to that painting, increasing the complexity and detail over time. Each time we want to include a new layer we need to include a `+` at the end of the proceeding layer to tell R and `ggplot2` that there are additional layers coming. Let's add (`+`) a new geom now:

```{r ggplot with geom_point, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	
	# Adding a geom to display data
	geom_point()	
```

If what we wanted was a quick and dirty figure to get a grasp of the trend in the data we can stop here. We can see that shootarea looks like it's increasing with weight in a linear fashion. So long as this answers the question we were asking from the data, we have a figure that is perfectly suited for personal use. Though for showing to other people we might want something a bit more developed. If we glance back to our "final figure" we can see that we have lines representing different nitrogen concentrations. We can include lines using a geom. If you have a quick look through the available geoms *here* (XXXinsert linkXXX), you might think that `geom_line()` would be appropriate. Let's try it.

```{r geom_line, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Adding geom_line
	geom_line()
```

Not quite what we were going for. The problem that we have is that `geom_line()` is actually just playing join-the-dots. The geom we actually want to use is called `geom_smooth()`. We can fix that very easily just by changing "line" to "smooth".

```{r geom_smooth, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Changing to geom_smooth
	geom_smooth()
```

Better, but still not what we wanted. The challenge here is that drawing a line is actually somewhat complicated. The way this line was drawn was using a method called "LOESS" which gives something very close to a moving average; useful in some cases, less so in others [`ggplot2` will use LOESS as default when you have < 1000 observations]. Instead of a wiggly line, we want a nice simple straight line to be drawn using a method called "lm" (short for linear model - see Chapter 5 for more details). Try looking at the help file, using `?geom_smooth`, to see what other options are available for the `method =` argument. While we're at it, let's get rid of the confidence interval ribbon around the line. I prefer to do this as I think it's clearer to the audience that this isn't a properly analysed line and to treat it as a visual aid only. We can do this at the same time by setting the `se =` argument (short for standard error) to FALSE.

Let's update the code to use a linear model without confidence intervals.

```{r geom_smooth lm, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Specifying the method as lm and se to false
	geom_smooth(method = "lm", se = FALSE)
```

That's exactly what we wanted, though it's still not matching the "final figure". We need `geom_smooth()` to draw lines for each level of nitrogen concentration. Getting `ggplot2` to do that is pretty straightforward. We can use the `colour =` argument within `aes()` (remember whatever we include in `aes()` will be something displayed in the figure) to tell `ggplot2` to draw a different coloured line depending on nitrogen concentration.

An aside: `ggplot2` was written with both UK English and American English in mind, so both colour and color spellings work in `ggplot2`.

```{r geom_smooth colour lm, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Including colour argument in aes()
	geom_smooth(aes(colour = nitrogen), method = "lm", se = FALSE)
```

We're getting closer, especially since `ggplot2` has automatically created a legend for us. At this point it's a good time to talk about where to include information - whether to include it within a geom or in `ggplot()`. When we include information such as `data =` and `aes()` in `ggplot()` we are setting those as the default, universal values which all subsequent geoms use. Whereas if we were to include that information within a geom, only that geom would use that specific information. In this case, we can easily move the information around and get exactly the same figure. 

```{r universal vrs geom, out.width = "75%", fig.align = "center"}
ggplot() +
	
	# Moved aes() and data into geoms
	geom_point(aes(x = weight, y = shootarea), data = flower) +
	geom_smooth(aes(x = weight, y = shootarea, colour = nitrogen), data = flower, method = "lm", se = FALSE)
```

Doing so we get exactly the same figure. This ability to move information around is surprisingly powerful. It can allow different geoms to display different (albeit similar) information (see more on this later).

For this worked example, we'll move the same information back to the universal `ggplot()`,but we'll also move `colour = nitrogen` into `ggplot()` so that we can have the points coloured according to nitrogen concentration as well.

```{r universal colours, out.width = "75%", fig.align = "center"}
# Moved colour = nitrogen into the universal ggplot()
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE)
```

This figure is now what I would consider to be the typical `ggplot2` figure (once you know to look for it, you'll see it everywhere). We have specified some information, with only a few lines of code at that, yet we have something that looks quite attractive. While it's not yet the "final figure" it is perfectly fit for purpose. You have now created you're first "pure" `ggplot`.

Let's keep going as we're aiming for something a bit more "sophisticated".

### Wrapping grids

Having made our "pure" `ggplot`, the next big obstacle we're going to tackle is the grid like layout of the "final figure" where the single figure has been split according to treatment and block, with new figures made for each combination. `ggplot2` includes options for determining the "facets" of a figure. We'll start off by using `facet_wrap()` to show what this can do. For `facet_wrap()` to work we need to specify a formula for how the facets will be defined (see `?facet_wrap` for more details and also for how to define facets without using a formula). You can read `~ treat` as saying "according to treatment". Let's see how it works:

```{r facet_wrap, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Splitting the single figure into multiple depending on treatment
	facet_wrap(~ treat)
```

That's pretty good, though we are missing the rows showing different blocks. Given that facet_wrap can use a formula, maybe we could simply include block in the formula? Remember that block refers to the region in the greenhouse where the plants were grown. Let's try it and see what happens.

```{r facet_wrap formula, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Adding "block" to formula
	facet_wrap(~ treat + block)
```

*Play around*: Try messing around with the formula to see what happens. Try putting `~ treat + flowers` or even `~ treat + block + flowers`. The important thing to remember here is that facet_wrap will create a new figure for each value in a variable. So when you wrap using a continuous variable like flowers, it makes a plot for every number of flowers counted. Be aware of what it is you are doing, but never be scared to experiment. Mistakes are easily fixed in R - it's not like a point and click figure maker where you'd have to go through all those clicks to get the same figure again. Made a mistake? Easy, change it back and rerun the code (see Chapter 8 for version control which takes this to the next level).

This facet layout is almost exactly what we want. _Almost_. But not exactly. In this case we actually want to be using `facet_grid()`, an alternative to `facet_wrap()`, which should put us back on track to make the "final figure".

```{r facet_grid, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Changing to facet_grid
	facet_grid(~ treat + block)
```

That's disappointing. It's pretty much the same as what we had before and is no closer to the "final figure". What we need to do to fix it is to rearrange our formula so that we say that block in relation to treatment (not in combination to).

```{r facet_grid formula, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Rearranging formula
	facet_grid(block ~ treat)
```

### Plotting multiple ggplots

And we're there. Although the styling is not the same as the "final figure" this is showing the exact same fundamental information. We can plot them side-by-side to see how they compare. To do so we will use an additional package called `patchwork`. Go ahead and install and load patchwork (see Chapter 1.5 if you need a refresher for how to do this).

```{r loading patchwork, eval = FALSE, echo = FALSE}
#install.packages("patchwork")
#library(patchwork)
```

An important note: For those who have used base R to produce their figure and are used to using `par(mfrow = c(2,2))` to plot up to four figures in two rows and two columns, be aware that this does not work for `ggplot2` objects. Instead you will need to use either `patchwork` or alternative packages such as `gridArrange` or `cowplot` or covert the `ggplot2` objects to grobs.

We'll need to go back to our previous code and do something clever. We can assign figures a name and then use that to call the figure whenever we run the name. For instance, I have assigned the "final figure" the name.... `final_figure` (I'm not a clever person).

```{r calling figure name, out.width = "75%", fig.align = "center"}
final_figure
```

We'll do the same with the figure we've created together:

```{r naming figure, out.width = "75%", fig.align = "center"}
# Naming our figure object
rbook_figure <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat)
```

Now when the code is run, the figure won't be presented. This will only happen when we run the name of the figure as code. Well use this at the same time as showing how `patchwork` works.

An old headache when using `ggplot2` was that it could be difficult to create a nested figure (different plots all part of the same figure). `patchwork` resolves this problem very elegantly and simply. We have two immediate and simple options with patchwork; figures on top of each other (operationalised with `/`) and figures side-by-side (operationalised with either `+` or `|`). Let's try.

```{r side-by-side patchwork, out.width = "75%", fig.align = "center"}
# rbook_figure | final_figure
```

Giving us a nested stacked figure.

*Play around*: Try to create a side-by-side version of the above figure (hint: try the other operators).

We can also assign nested `patchwork` figures a name and use this in turn to create labels for individuals figures.

```{r labelled nested, out.width = "75%", fig.align = "center"}
# nested_compare <- rbook_figure + final_figure

#nested_compare + 
#	plot_annotation(tag_levels = "A")
```

### Make it your own

While we have a great figure already that shows the data we want it to show, it uses all of the default stylistic options. While the default options are arguably good, they may not be what we want ourselves. Maybe we're going to use this figure in a presentation and we want to make sure someone in the very back of the room can easily read the figure. Maybe we want to use our own colour scheme. Maybe we want to change the grey background to a nice bright neon pink. In essence, maybe we want to decide things for ourselves. This next section will go through how to customise the appearance of our figure.

Let's start with the easier stuff, namely changing the size of the points using the `size =` argument. Before we do, have a think about where we'd include the argument? Should it be in `ggplot()` or `geom_point()`?

```{r change size, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	
	# Including size argument to change the size of the points
	geom_point(size = 2) +
	
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat)
```

Straightforward, we changed the size from the default of `size = 1` to a value that we decide for ourselves. What happens if you included size in `ggplot()` or within the `aes()` of `geom_point()`?

If we wanted to change the shape of the points to reflect nitrogen concentrations, how do you think we'd do that? We'd use the `shape =` argument, but this time we need to include an `aes()` within `geom_point()` because we want to include specific information to be displayed on the figure.

```{r change shape, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	
	# Including shape argument to change the shape of the points
	geom_point(aes(shape = nitrogen), size = 2) +
	
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat)
```

Try including `shape = nitrogen` without also including `aes()` and see what happens.

We're getting closer and closer to the "final figure". Another thing we may want to be able to do is change the transparency of the points. While it's not actually that crucial here (arguably it might not be a good idea), changing the transparency of points is really valuable when you have lots of data and big clusters of points can be hidden. Doing this is, again, surprisingly easy, accomplished using the `alpha =` argument. Again, ask yourself where you think the `alpha =` argument should be included.

```{r change alpha, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	
	# Including alpha argument to change the transparency of the points
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat)
```

We can also include defined labels for the x and y axis. There are a couple of ways to do this, but my preferred way is the same as used in base R figures; using `xlab()` and `ylab()`. As we are going to be creating new layers and adding them onto the figure, we'll need to convey this to `ggplot2` using `+`.

```{r axis labels, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	
	# Adding layers for x and y labels
	xlab("Weight of flower (g)") +
	ylab("Area of shoot (cm^2)")
```

Great. Just as we wanted, though getting the "(cm^2)" to show the square as a superscript would be ideal. Here, we're going to accomplish that using a function which is part of base R called `bquote()` which allows for special characters to be shown.

```{r bquote, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	
	# Using bquote to get mathematically correct formatting
	ylab(bquote("Area of shoot"~(cm^2)))
```

Let's now work on the legend title while also including a caption to warn people looking at the figure to treat the trend lines with caution. We'll use a new layer called `labs()`, short for labels, which we could have also used for specifying the x and y labels (we didn't only for demonstration purposes, but give it a shot). `labs()` is a fairly straightforward function. Have a look at the help file (using `?labs`) to see which arguments are available. We'll be using `caption =` for the caption, but notice that there isn't an argument for `legend =`? That's because the legend is in fact multiple pieces of information; one being colour and one being shape. So instead of `legend =` we'll use `colour =` and `shape =`. Here's how we do it:

```{r extra labels, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +

	# Adding labels for shape, colour and a caption	
	labs(shape = "Nitrogen Concentration", colour = "Nitrogen Concentration", caption = "Lines are only to suggest trends")
```

*Play around*: Try removing `colour =` or `shape = ` from `labs()` to see what happens. The resulting legends are why we need to specify both colour and shape (and call it the same thing).

Now is a good time to introduce "backslash n". This is a base R feature which can be thought of as pressing Return in a word processor. It tells R that a string should be continued on a new line. We can use that with "Nitrogen Concentration" so that the legend title becomes more compact.

```{r compact labels, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +

	# Including \n to split legend title over two lines	
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends")
```

We can now move onto some more wholesale-stylistic choices using the much loved themes of `ggplot2`.

### Setting the theme

`ggplot2` contains so called themes. Themes control the base style of a `ggplot.` Let's play around with themes using some skills we've already learnt; assigning plots to objects and plotting multiple `ggplots` in a single figure to explore some theme options. We assign themes by creating a new layer with `theme_X()`.

```{r testing themes, out.width = "75%", fig.align = "center"}
classic <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	
	# Classic theme
	theme_classic()

bw <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	
	# Black and white theme
	theme_bw()

minimal <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +

	# Minimal theme
	theme_minimal()

light <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +

	# Light theme
	theme_light()

#(classic | bw) /
#	(minimal | light)
```

In terms of finding a theme that most closely matches our "final figure", it's probably going to be `theme_classic()`. There are additional themes available to you, and even more available online. `GGthemes` is a package you can download to get even more theme options. The BBC even have their own `ggplot2` theme called "BBplot" (though I personally don't like it too much for scientific figures). Indeed, you can even make your own theme which is what we'll work on next. To begin with, we'll have a look to see how `theme_classic()` was coded. We can do that easily enough by just writing the function name without the paranethesis (brackets).

```{r theme_classic}
theme_classic
```

Let's use this code as the basis for our own theme and modify it according to our needs.  We'll call the theme, `theme_rbook`. Not all of the options will immediately make sense, but don't worry about this too much for now. Just know that the settings we're putting in place are:

- Font size for axis titles = 20
- Font size for x axis text = 10
- Font size for y axis text = 10
- Font for caption = 10 and italics
- Background colour = white
- Background border = black
- Axis lines = black
- Strip colour (for facets) = black
- Strip text colour (for facets) = white
- Legend box colours = blank 

This is by no means an exhaustive list of features you can specify in your own theme, but this will get you started. Of course, there is no need to use a personalised theme as the pre-built options are perfectly suitable.

```{r rbook theme}
theme_rbook <- function(base_size = 20, base_family = "", base_line_size = base_size/22, base_rect_size = base_size/22) {         
  theme( 
    axis.title = element_text(size = 20),                               
    axis.text.x = element_text(size = 10),                              
    axis.text.y = element_text(size = 10),                              
    plot.caption = element_text(size = 10, face = "italic"),            
    panel.background = element_rect(fill="white"),                      
    panel.border = element_rect(colour = "black", fill=NA, size=0.5),
    axis.line = element_line(size = 1, colour = "black"),
    strip.background =element_rect(fill = "black"),
    strip.text = element_text(colour = "white"),
    legend.key=element_blank()
  )
}
```

`theme_rbook()` is now available for us to use just like any other theme. Let's try remaking our figure using our new theme.

```{r rbook figure, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +

	# Updated theme to our theme_rbook
	theme_rbook()
```

### Prettification

We've pretty much got to our "final figure". We just have a few final adjustments to make, and we'll do so in order of difficulty.

Let's remind ourselves of what that "final figure" looked like. Remember, since I have previously stored the figure as `final_figure` I can just type that into the console and pull up the figure.

```{r final figure reminder, out.width = "75%", fig.align = "center"}
final_figure
```

Let's begin the final push by including that dashed horizontal line at about 80 on our y axis. This represents the overall mean area of a shoot, regardless of weight of flower, nitrogen concentration, treatment, or block. To draw a horizontal line we use a geom called `geom_hline()`, and the most important thing we need to specify is the y intercept value (in this case being our mean area of a shoot). We can also change the type of line using the argument `linetype =` and also the colour (as we did before). Let's see how it works.

```{r geom_hline, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +

	# Added a horizontal line using geom_hline
	geom_hline(aes(yintercept = mean(shootarea)), size = 0.5, colour = "black", linetype = 3) +
	
	theme_rbook()
```

Notice how we included the function `mean(shootarea)` within the `geom_hline()` function? We could also do that externally to the `ggplot2` code and get the same result.

```{r shootarea mean}
mean(flower$shootarea)
```

```{r geom_hline alternative, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +

	# Manually entering mean value
	geom_hline(aes(yintercept = 79.8), size = 0.5, colour = "black", linetype = 3) +
	
	theme_rbook()
```

Exactly the same figure but produced in a slightly different way (the point being that there are always multiple ways to get code to do what you want), which brings us ever closer to that "final figure".

Let's tackle that "overall" nitrogen effect. This overall line is effectively the figure we produced much earlier when we learnt how to get a line drawn using a linear model. But we are already using `geom_smooth()`, surely we can't use it again? This may shock and/or surprise you so please ensure you are seated. You _can_ use `geom_smooth()` again. In fact you can use it as many times as you want. You can use any layer as many times as you want! Isn't the world full of wonderful miracles? ... Anyway, here's the damn code...

```{r 2nd geom_smooth, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Adding a ***SECOND*** geom_smooth :O
	geom_smooth(method = "lm", se = FALSE, linetype = 2, alpha = 0.6, colour = "black") +
	
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	geom_hline(aes(yintercept = 79.8), size = 0.5, colour = "black", linetype = 3) +
	theme_rbook()
```

That's great! But you should be asking yourself why that worked. Why when we specified the first `geom_smooth()` did it draw 3 lines, whereas the second time we used `geom_smooth()` it just drew a single line? The secret lies in a "conflict" (it isn't actually a conflict but I'll call it that here) between the colour specified in the universal `ggplot()` and the colour specified in the second `geom_smooth()`. Notice how in the second we've specifically told `ggplot2` that the colour will be black, while prior to this it drew lines based on the number of groups (or colours) in nitrogen? In "overriding" the universal `ggplot()` with a geom specific argument we're able to get `ggplot2` to plot what we want.

The only things left now are to change the colour and the shape of the points to something of our choosing and include the "overall" trend line in the legend. We'll begin with the former; changing colour and shape to something we specifically want. When I first started using `ggplot2` this was actually the thing which caused me most difficulty. I think the reason is, that to manually change the colours actually requires an additional layer, where I assumed this would be done in either the universal `ggplot()` or in a geom.

Instead of doing this within the specific geom, we'll use `scale_colour_manual()` as well as `scale_shape_manual()`. Doing it this way will allow us to do two things at once; change the shape and colour to our choosing, and assign labels for these (much like what we did with `xlab()` and `ylab()`). Doing so is not too complex but will require nesting a function within another function, using `c()` (see chapter XXX for a reminder on the concatenate function). Let's see how we can do it:

```{r scale manual, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	geom_smooth(method = "lm", se = FALSE, linetype = 2, alpha = 0.6, colour = "black") +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	geom_hline(aes(yintercept = 79.8), size = 0.5, colour = "black", linetype = 3) +
	
	# Setting colour and associated labels
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4"),
											labels = c("High", "Medium", "Low")) +
	
	# Setting shape and associated labels
	scale_shape_manual(values = c(15,17,19),
										 labels = c("High", "Medium", "Low")) +
	
	theme_rbook()
```

To make sense of that code (or any code for that matter) try running it piece by piece. For instance in the above code, if we run `c("violetred3", "limegreen", "purple4")` we'll get a list of those strings. That list is then passed on to `scale_colour_manual()` as the colours we wish to use. Since we only have three nitrogen concentrations, it will use these three colours. Try including an additional colour in the list and see what happens (if you place the new colour at the end of the list, nothing will happen since it will use the first three colours of the list - try adding it to the start of the list). The same is true for `scale_shape_manual()`.

But if you're paying close attention you'll notice that there's a mistake with the figure now. What should be labelled "Low" is actually labelled "Medium" (the green points and line are our low nitrogen concentration, but `ggplot2` is saying that it is purple). `ggplot2` hasn't made a mistake here. We have. Remember that code is purely logical (or a golem using R McElreath's terminology). It will do explicitly what it is told to do, and in this case we have told it to call the labels High, Medium and Low. We could have just as easily told `ggplot2` to call them Pretoria, Tokyo, and Copenhagen. The lesson here is to always be critical of what your outputs are. Never assume that you are omnipotent and will never make mistakes. Double check everything you do.

So how do we fix this? We need to do a little data manipulation to rearrange our factors so that the order goes High, Medium, Low. Let's do that:

```{r relevel factor}
flower$nitrogen <- factor(flower$nitrogen, levels = c("high", "medium", "low"))
```

With that done, we can re-do our above code to get a correct figure.

```{r corrected factor level, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(method = "lm", se = FALSE) +
	geom_smooth(method = "lm", se = FALSE, linetype = 2, alpha = 0.6, colour = "black") +
	facet_grid(block ~ treat) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	geom_hline(aes(yintercept = 79.8), size = 0.5, colour = "black", linetype = 3) +
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4"),
											labels = c("High", "Medium", "Low")) +
	scale_shape_manual(values = c(15,17,19),
										 labels = c("High", "Medium", "Low")) +
	theme_rbook()
```

And we've done it! Our final figure matches the "final figure" exactly. While absolutely not an exhaustive list of what you can do with `ggplot2`, this will hopefully help when you're making your own from scratch or copying `ggplots` made by other people (in which case hopefully this will help you understand what they've done). 

## Tips and tricks

For this section I'll use the version of the final figure without the `facet_grid()`. With this plot, I'll run through some tips and tricks that I wish I had learnt when I started using `ggplot2`.

### Axis limits and zooms

Fairly often, you may want to limit the range of your axes. Maybe you want to focus a particular part of the data to really tease apart any patterns occuring there. Whatever the reason, it's a useful skill to know, and with most things code, there are a couple of ways to do this. I'll show two here; `xlim()` and `ylim()` and `coord_cartesian()`. Using both of these we'll set the x axis to only show data between 10 and 15 g and the yaxis to only show the area of the shoot between 50 and 150. We'll start with limiting the axes:

```{r axis limits, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(colour = "black", method = "lm", se = F, linetype = 2, alpha = 0.6) +
	geom_smooth(aes(colour = nitrogen), method = "lm", se = F, size = 1.2) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = "black", linetype = 3) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4"),
											labels = c("High", "Medium", "Low")) +
	scale_shape_manual(values = c(15,17,19,21),
										 labels = c("High", "Medium", "Low")) +
	theme_rbook() +
	
	# New x and y limits
	xlim(c(10, 15)) +
	ylim(c(50, 150))
```

Notice the warning messages we get, telling us that n rows contain either missing or non-finite values? That's because we've essentially chopped out a huge part of our data using this method (everything outside of the ranges that we specified). As a result of doing this our lines have no completely changed direction. Notice that for low nitrogen concentration, the line is being drawn using only two points? This may, or may not be a problem depending on the aim we have, but we can use an alternative method; `coord_cartesian()`.

`coord_cartesian()` works in much the same way, but instead of chopping out data, it instead zooms in. Doing so means that the entire dataset is maintained (and any trends are maintained).

```{r coord_cartesian, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(colour = "black", method = "lm", se = F, linetype = 2, alpha = 0.6) +
	geom_smooth(aes(colour = nitrogen), method = "lm", se = F, size = 1.2) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = "black", linetype = 3) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4"),
											labels = c("High", "Medium", "Low")) +
	scale_shape_manual(values = c(15,17,19,21),
										 labels = c("High", "Medium", "Low")) +
	theme_rbook() +
	
	# Zooming in rather than chopping out
	coord_cartesian(xlim = c(10, 15),	ylim = c(50, 150))
```

Notice now that the trends are maintained (as the lines are being informed by data which are off-screen). I would generally advise using `coord_cartesian()` as it protects you against possible misinterpretations.

### Layering layers

Remember that `ggplot2` works like painting. Let's imagine we were one of the great renaissance painters. We've just finished the focal point of our painting, the half naked Duke of Toulouse looking moody or something. Now that we've finished painting the honourable Duke, we proceed to paint the background, a beautiful landscape showing the Pyrenees mountains in the distance. Unfortunately, in doing so we've painted over the Duke, because the order of our layers were wrong. We get our heads chopped off, but learn a valuable lesson in the process: the order of layers matter.

The exact same is true in `ggplot2` (minus the chopping off of heads, though your situation may vary). The layers are read and "painted" in order of their appearance in the code. If `geom_point()` comes before `geom_col()`, then your points may well end up being hidden. To fix this is especially easy, we simply need to move the layers up or down in the code. A useful tip for those using Rstudio, is that you can do move lines of code especially easily. Simply click on a line of code, hold down Alt and then press either the up or down arrows, and the entire line will move up or down as well. For multiple lines of code, simply highlight all those lines you want to move and press Alt + Up/Down.

We'll move the Overall black dashed line later in the code so that it is superimposed:

```{r layering layers, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(aes(colour = nitrogen), method = "lm", se = F, size = 1.2) +
	
	# Moved one line down
	geom_smooth(colour = "black", method = "lm", se = F, linetype = 2, alpha = 0.6) +
	
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = "black", linetype = 3) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4"),
											labels = c("High", "Medium", "Low")) +
	scale_shape_manual(values = c(15,17,19,21),
										 labels = c("High", "Medium", "Low")) +
	theme_rbook()
```

It's not the clearest example, but give it a shot with your own data.


To round off this chapter, I will take you on a whistle-stop tour of some of the common types of plots you can make in the aptly named Beastiary section (which is totally different from a Bestiary).

## A ggplot Beastiary

What follows is a quick run through of example `ggplots`. These will predominantly be done by changing the geoms used, but there will be additional slight tweaks which I'll highlight.

### Density plot

Below is a density plot which is much like a histogram. The x axis shows observations of given numbers of flowers, while the y axis is the density of observations (roughly equivalent to number of rows with that many flowers). Each density is coloured according to nitrogen concentration, though note that we're using `fill =` instead of `colour =`. Try using colour instead to see what happens.

Notice that we haven't used `data = flowers` here and instead just used `flowers`? When an object is not assigned with an argument, `ggplot2` will assume that it is the dataset. We're using that here, but I actually prefer to explicitly state what arguments are being fulfilled in my own work.

```{r density plot, out.width = "75%", fig.align = "center"}
ggplot(flower) +
	geom_density(aes(x = flowers, fill = nitrogen), alpha = 0.5) +
	labs(y = "Density", x = "Number of Flowers", fill = "Nitrogen\nConcentration") +
	scale_fill_manual(labels = c("High", "Medium", "Low"),
										values = c("steelblue4", "orangered4", "black")) +
	theme_rbook()
```

### Histogram

Next is a histogram (a much more traditional version of a density plot). There are a couple of things to take note of here. The first is that `flower$block` is numeric and not a factor. We can correct that here fairly easily using the `factor()` function to convert it from numeric to factor (though ideally we'd have done this before - see Chapter 3). The other thing to take note of is that I've specified `bins = 20`. The number of bins control how many times the y-axis is broken up to show the data. Try increasing and decreasing to see the effect.

```{r histogram, out.width = "75%", fig.align = "center"}
ggplot(flower) +
	geom_histogram(aes(x = flowers, fill = factor(block)), colour = "black", bins = 20) +
	labs(y = "Count", x = "Number of Flowers", fill = "Greenhouse\nBlock") +
	scale_fill_manual(labels = c("1", "2"),
										values = c("steelblue4", "firebrick4")) +
	theme_rbook()
```

### Boxplot

Boxplots are a classic way to show to spread of data, and they're easy to make in `ggplot2`. The dark line in the middle of the box shows the median, the boxes show the 25th and 75th percentiles (which is different from the base R `boxplot()`), and the whiskers show 1.5 times the inter-quartile range (i.e. the distance between between the first and third quartiles). We can also make the boxes notched using the argument `notch = TRUE`. Notches extend (1.58 times the inter-quartile range) / square root of the number of observations. If notches do no overlap, it suggest (but only suggests) there may be a significant difference between groups.

```{r boxplot, out.width = "75%", fig.align = "center"}
ggplot(flower) +
	geom_boxplot(aes(y = flowers, x = nitrogen), notch = TRUE) +
	labs(y = "Number of Flowers", x = "Nitrogen Concentration") +
	theme_rbook()
```

### Violin plots

Violin plots are an increasingly popular alternative to boxplots. They display much of the same information, as well as showing a version of the density plot above (imagine each violin plot, cut in half vertically, showing the overall distribution of the data). In the plot below the figure is slightly more complex than those above and so deserves some explanation.

Within `geom_violin()` we've included `draw_quantiles =` where we've specified we want quantile lines drawn at the 25, 50 and 75 quantiles (using the `c()` function). In combination with `geom_violin()` we've also included `geom_jitter()`. `geom_jitter()` is similar to `geom_point()` but induces random spread of the points, often helpful when points would otherwise be clustered. Within `geom_jitter()` we've also set `height = 0`, and `width = 0.1` which specifies how much to jitter the points in a given dimension (here essentially telling `ggplot2` not to jitter by height, and only to jitter width by a small amount).

Finally, I'm also using this plot to show `scale_y_log10`. Hopefully this is largely self-explanatory (it converts the y-axis to the log10 scale). There are additional scaling options for axis (for instance `scale_y_sqrt()`).

```{r violin plot, out.width = "75%", fig.align = "center"}
ggplot(flower) +
  geom_violin(aes(y = flowers, x = nitrogen, fill = nitrogen), draw_quantiles = c(0.25, 0.5, 0.75), alpha = 0.4) +
  geom_jitter(aes(y = flowers, x = nitrogen, colour = nitrogen), height = 0, width = 0.1) +
	scale_fill_manual(labels = c("High", "Medium", "Low"),
										values = c("darkorchid4", "darkorchid2", "darkorchid1")) +
	scale_colour_manual(labels = c("High", "Medium", "Low"),
											values = c("darkorchid4", "darkorchid2", "darkorchid1")) +
	labs(y = "Number of Flowers", x = "Nitrogen Concentration") +
	scale_y_log10() +
	theme_rbook()
```
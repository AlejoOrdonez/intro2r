# Graphics in R {#graphics_r}

For many people, one of their favourite uses of `R` is in making figures. These can either take the form of a quick dirty plot to allow you to get a feel for what's going on in your dataset, or fancier/more complex figures to use in a publication or report. This process is often as close as many analysts/scientists get to having a professional creative side (at least that's true for me), and it's something which those folk take great pride in.

As stated in the introduction, one of the many reasons for the rise in the popularity of `R` is due to it's ability to produce publication standard figures (as well as those quick and dirty figures - which are the type you and I and everyone else will produce most of). Not only can R users make figures well suited for publication, but producing figures in `R` allows for lots of customisation, in turn allowing users to create their own particular styles and brands of figures (well beyond the beyond cookie-cutter styles in more traditional click and point programs). Because of this inherent flexibility when producing figures, the data visualisation side of R and supporting packages has grown substantially over the years.

In this chapter, we will focus on creating figures through using a specialised package called `ggplot2`.

Before we get going with making some plots of the gg variety, how about a quick little history of one of the most commonly used packages in R? `ggplot2` was based on a book called _Grammar of Graphics_ (hence the gg in `ggplot2`) by Leland Wilkinson [yours for only £100 or so](https://www.springer.com/gp/book/9780387245447). But before you spend £100 see [here](https://www.jstatsoft.org/article/view/v017b03/v17b03.pdf) for an interesting summary of Wilkinson's book. 

Briefly, Wilkinson's idea (one of them anyway) in _grammar of graphics_ was that figures can be broken down into consituent parts, such as layers (more on this later). While Wilkinson would eventually go on to become vice-president of SPSS, his (and his co-author's) ideas would, never-the-less, make their way into R via `ggplot`. 

In 2007 `ggplot2`was officially released by Hadley Wickham. By 2017 the package was said to have been downloaded 10,000,000 times. `ggplot2` now has many secondary packages that use it either as a foundation for expanding on or for interfacing with (some statistical packages now have accompanying `ggplot2` interfaces for producing figures).

It is important to note here that `ggplot2` is not required to make "fancy" figures. If you'd prefer to ue base R then go ahead. Exactly equivalent figures are possible in base R. The difference between`ggplot2` and base is to do with how you _get_ to the end product rather than any differences in the end product itself. This is, never-the-less, a common belief almost certainly due to the fact that making a moderately attractive figure is easier to do with `ggplot2` as many decisions are made for the user, without you necessarily even knowing that a decision was ever made!

With that in mind, let's get started making some figures.

\

## Beginning at the end

The approach I'll use in this chapter will be to start off by showing you a figure which I reckon is at a standard that you could use in a poster or presentation. Using that as the aim, we will then work towards it step-by-step. You should not view this final figure as any sort of holy grail. For instance, you would be very unlikely to use this in a publication (you'd be much more likely to use some results of your hard earned analysis). Regardless, this "final figure" is, and will only ever be, a reflection of what my personal preferences are. As with anything subjective, you may well disagree, and to some extent I hope you do. Much better that we all have slightly (or grossly) different views on what a good figure is - otherwise we may as well go back to using cookie-cutter figures.

So what is the figure we're going to make together?

```{r final figure - start, echo = FALSE, out.width = "75%", fig.align = "center", warning = FALSE}
flower <- read.csv("data/flower.csv")
library(ggplot2)

theme_deon <- function(base_size = 20, base_family = "", base_line_size = base_size/22, base_rect_size = base_size/22) {         
  theme( 
    axis.title = element_text(size = 20),                               
    axis.text.x = element_text(size = 10),                              
    axis.text.y = element_text(size = 10),                              
    plot.caption = element_text(size = 10, face = "italic"),            
    panel.background = element_rect(fill="white"),                      
    axis.line = element_line(size = 1, colour = "black"),
    strip.background =element_rect(fill = "black"),
    panel.border = element_rect(colour = "black", fill=NA, size=0.5),
		strip.text = element_text(colour = "white"),
		legend.key=element_blank()
  )
}

final_figure <- ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) +
	geom_smooth(aes(colour = "Overall", shape = "Overall"), method = "lm", se = F, linetype = 2, alpha = 0.6) +
	geom_smooth(aes(colour = nitrogen), method = "lm", se = F, size = 1.2) +
	geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = "black", linetype = 3) +
	xlab("Weight of flower (g)") +
	ylab(bquote("Area of shoot"~(cm^2))) +
	labs(shape = "Nitrogen\nConcentration", colour = "Nitrogen\nConcentration", caption = "Lines are only to suggest trends") +
	# Additional arguments
	scale_colour_manual(values = c("violetred3", "limegreen", "purple4", "black"),
											labels = c("High", "Medium", "Low", "Overall")) +
	scale_shape_manual(values = c(15,17,19,21),
										 labels = c("High", "Medium", "Low", "Overall")) +
	theme_deon() +
	facet_grid(block~treat)

final_figure
```

Before we go further, let's take a second and talk about what this figure is literally showing. On the y axes of the four plots we have the area of the shoot and the x axes we have the weight of a flower. Each column shows the two treatments of the dataset (whether the tip of the flower was cut or not) and the two rows show which block of the greenhouse the plants were grown in (block 1 and block 2). The thin dotted line shows the mean shoot area regardless of the weight of the flowers, the treatment or the block. For our purposes, we won't worry about the biology here (though you should absolutely care deeply about that in your own data); all we care about here is that we are giving the audience lots of information in a relatively readable format.

## The start of the end

The first step in producing a `ggplot` is the easiest! We just need to install and then load the package. Use the skills you learnt in Chapter 1.5 to install and load the package. Note that although I and pretty much everyone else refer to the package as `ggplot`, it's proper name is `ggplot2`, so be careful to call it by it's proper name when coding.

```{r installing & loading ggplot}
library(ggplot2)
```

With that taken care of, let's make our first `ggplot`!

### The purest of ggplots

During the R course this book is based on, the students are asked at one point to shout out all of the functions they have either learnt in the course or heard of/used before. At this point in the course we have not touched on `ggplot`, but one year a student shouted out `ggplot()`. When asked what the `ggplot()` function does, they said that it makes a `ggplot`. This makes complete and utter sense. So let's make a `ggplot` now:

```{r pure ggplot, out.width = "75%", fig.align = "center"}
ggplot()
```

And here we have it. A fully formed, perfect `ggplot`. We may have a small issue though. Some puritan data visualisers/plottists/figurines make the claim that figures should include some form of information beyond a light grey background. As loathe as I am to agree with pureists, I will do so here. We really should include some data. To do so, we need some data.

We'll keep using the flower dataset that you used in the earlier chapters. Let's have a quick reminder of what the data looked like.

```{r str of flower}
str(flower)
```

We know from the "final figure" that we want shootarea on the y axis and weight on the x axis. To do so in `ggplot` we need to make use of the `aes()` function and also fullfill the `data =` argument. `aes` is short of aesthetics, and it's the function we use to specify what we want displayed in the figure. Let's try it now:

```{r ggplot with xy axis, out.width = "75%", fig.align = "center"}
# Including aesthetics for x and y axess as well as speficying the dataset
ggplot(aes(x = weight, y = shootarea), data = flower) 
```

That's already much better. At least it's no longer a blank grey canvas. We've now told `ggplot` what we want as our x and y axes as well as where to find that data. But what's missing here is where we tell `ggplot` _how_ to display that data. This is now the time to introduce you to "geoms" or geometric objects. Geoms are the way that `ggplot` displays information. For instance `geom_point()` tells `ggplot` that you want the information to be displayed as points (making scatterplot possible). Given that the "final figure" uses points, this is clearly the appropriate geom to use here.

Before we can do that we need to talk about the coding structure used by `ggplot`. The analogy that I and many others use is to say that making a figure in `ggplot` is much like painting. What we've done in the above code is making our "canvas". Now we are going to add sequential layers to that painting, increasing the complexity and detail over time. Each time we want to include a new layer we need to include a `+` at the end of the proceeding layer to tell R and `ggplot` that there are additional layers coming. Let's add (`+`) a new geom now:

```{r ggplot with geom_point, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	
	# Adding a geom to display data
	geom_point()	
```

If what we wanted was a quick and dirty figure to get a grasp of the trend in the data we can stop here. We can see that shootarea looks like it's increasing with weight in a fairly linear fashion. So long as this answers a question we had this figure is perfectly suited for personal use. Though for showing to other people we might want something a bit more developed. If we glance back to our "final figure" we can see that we have lines representing different nitrogen concentrations. We can include lines using a geom. If you have a quick look through the avaialble geoms *here*, you might think that `geom_line()` would be appropriate. Let's try it.

```{r geom_line, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Adding geom_line
	geom_line()
```

Not quite what we were going for. The problem that we have is that `geom_line()` is actually just playing join-the-dots. The geom we actually want to use is called `geom_smooth()`. We can fix that very easily just by changing "line" to "smooth".

```{r geom_smooth, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Changing to geom_smooth
	geom_smooth()
```

Better, but still not what we wanted. The challenge here is that drawing a line is actually somewhat complicated. The way this line was drawn was using a method called "LOESS" which gives something very close to a moving average; useful in some cases, less so in others [`ggplot` will use LOESS as default when you have < 1000 observations]. Instead of a wiggly line, we want a nice simple straight line to be drawn using a method called "lm" or (linear model - see Chapter XXX for more details). Try `?geom_smooth` to see what other options are avialble for the `method =` argument. While we're at it, let's get rid of the confidence interval ribbon around the line. I prefer to do this as I think it's clearer to the audience that this isn't a properly analysed line and to treat it as a visual aid only. We can do this at the same time using the `se =` argument.

Let's update the code to use a linear model.

```{r geom_smooth lm, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Specifying the method as lm and se to false
	geom_smooth(method = "lm", se = FALSE)
```

That's exactly what we wanted, though it's still not matching the "final figure". We need `geom_smooth()` to draw lines for each level of nitrogen concentration. Getting `ggplot` to do that is pretty straightforward. We can use the `colour =` within `aes()` to use tell `ggplot` to draw a different coloured line depending on nitrogen concentration.

```{r geom_smooth colour lm, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea), data = flower) +
	geom_point() +
	
	# Including colour argument in aes()
	geom_smooth(aes(colour = nitrogen), method = "lm", se = FALSE)
```

We're getting closer, but this is actually a good time to talk about where to include information - whether to include it in a geom or in `ggplot()`. When we include information such as `data =` and `aes()` in `ggplot()` we are setting those as the default, universal values which all subsequent geoms use. We can easily move the information around and get exactly the same figure. 

```{r universal vrs geom, out.width = "75%", fig.align = "center"}
ggplot() +
	
	# Moved aes() and data into geoms
	geom_point(aes(x = weight, y = shootarea), data = flower) +
	geom_smooth(aes(x = weight, y = shootarea, colour = nitrogen), data = flower, method = "lm", se = FALSE)
```

Doing so we get exactly the same figure. This ability to move information around is surprisingly powerful. It can allow different geoms to display different (albiet similar) information (see more on this later).

For this worked example, we'll move the information back to the universal `ggplot()` so that we can have the points coloured as well.

```{r universal colours, out.width = "75%", fig.align = "center"}
# Moved colour = nitrogen into the universal ggplot()
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE)
```

This figure is now what I would consider to be the typical `ggplot` figure. We have specified some information, and with only a few lines of code, yet we have something that looks quite attractive. While it's not yet the "final figure" it is perfectly fit for purpose. You have now created you're first "pure" `ggplot`.

Once you've seen this figure you will see version similar to it more and more often. But we're aiming for something a bit more developed.

### Wrapping grids

Having made our "pure" `ggplot`, the next big obstacle we're going to tackle is the grid like layout of the "final figure". `ggplot` includes options for determining the "facets" of a figure. We'll start off by using `facet_wrap()` to show what this can do. For `facet_wrap()` to work we need to specify a formula for how the facets will be defined (see `?facet_wrap` for more details and also for how to define facets without using a formula).

```{r facet_wrap, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Including a facet
	facet_wrap(~ treat)
```

That's pretty good, though we are missing the rows showing different blocks. Given that facet_wrap can use a formula, maybe we could simply include block in the formula? Remember that block refers to the region in the greenhouse where the plants were grown (it's not something special to `ggplot` in this case). Let's try it and see what happens.

```{r facet_wrap formula, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Adding "block" to formula
	facet_wrap(~ treat + block)
```

*Side quest*: Try messing around with the formula to see what happens. Try putting `~ treat + flowers` or even `~ treat + block + flowers`. The important thing to remember here is that facet_wrap will create a new figure for each value in a variable. So when you wrap using a continuous variable like flowers, it makes a plot for every number of flowers counted. Be aware of what it is you are doing, but never be scared to experiment. Mistakes are easily fixed in R - it's not like a point and click figure maker where you'd have to go through all those clicks to get the same figure again. Made a mistake? Easy, change it back and rerun the code (see Chapter XXX for version control which takes this to the next level).

This figure is almost exactly what we want. _Almost_. But not exactly. In this case we actually want to be using `facet_grid()`, an alterative to `facet_wrap()` which should put us back on track to make the "final figure".

```{r facet_grid, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Changing to facet_grid
	facet_grid(~ treat + block)
```

Oh. Dissapointing. It's pretty much the same as we had before and is no closer to the "final figure". What we need to do to fix it is to rearrange our formula so that we say that block in relation to treatment (not in combination to).

```{r facet_grid, out.width = "75%", fig.align = "center"}
ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	
	# Rearranging formula
	facet_grid(block ~ treat)
```

And we're there. Although the styling is not the same as the "final figure" this is showing the exact same information. We can plot them side-by-side to see how they compare. To do so we will use an additional package called `patchwork`. Go ahead and install and load patchwork (see Chapter 1.5 if you need a refersher for how to do this).

```{r loading patchwork, eval = FALSE, echo = FALSE}
install.packages("patchwork")
library(patchwork)
```

We'll need to go back to our previous code and do something clever. We can assign figures a name and then use that to call the figure whenever we run the name. For instance I have assigned the "final figure" the name.... `final_figure` (I'm not a clever person).

```{r calling figure name, out.width = "75%", fig.align = "center"}
final_figure
```

We'll do the same with the figure we've created together:

```{r naming figure, out.width = "75%", fig.align = "center"}
# Naming our figure object
rbook_figure <- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) +
	geom_point() +
	geom_smooth(method = "lm", se = FALSE) +
	facet_grid(block ~ treat)
```

Now when the code is run, the figure won't be presented. This will only happen when we run the name of the figure as code. We can do this while also showing `patchwork`.
An old headache when using `ggplot` was that it could be difficult to create a nested figure (different plots all part of the same figure). Patchwork resolves this problem very elegantly and simply. We have two immediate and simple options with patchwork; figures on top of each other (operationalised with `/`) and figures side-by-side (operationalised with either `+` or `|`). Let's try.

```{r side-by-side patchwork, out.width = "75%", fig.align = "center"}
rbook_figure + final_figure
```

Giving us a nested side-by-side figure.

*Side quest*: Try to create a stacked version of the above figure.

We can also assign nested `patchwork` figures a name and use this in turn to create labels for individuals figures.

```{r labelled nested, out.width = "75%", fig.align = "center"}
nested_compare <- rbook_figure + final_figure

nested_compare + 
	plot_annotation(tag_levels = "A")
```

















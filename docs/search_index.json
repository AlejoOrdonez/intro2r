[
["index.html", "A Introduction to R Preface ", " A Introduction to R Alex Douglas, Francesca Mancini, Deon Roos, Ana Couto &amp; David Lusseau Draft: April 4, 2020 Preface "],
["the-aim-of-this-book.html", "0.1 The aim of this book", " 0.1 The aim of this book The purpose of this book is to introduce you to using R, a powerful and flexible interactive environment for statistical computing and research. R in itself is not difficult to learn, but as with learning any new language (spoken or computer) the initial learning curve can be a little steep and somewhat daunting. We have tried to simplify the content of this book as much as possible and have based it on our own personal experience of teaching (and learning) R over the last 15 years. It is not intended to cover everything there is to know about R - that would be an impossible task. Neither is it intended to be an introductory statistics course, although you will be using some simple statistics to highlight some of R’s capabilities. The main aim of this book is to help you climb the initial learning curve and provide you with the basic skills and experience (and confidence!) to enable you to further your experience in using R. "],
["who-is-this-book-for.html", "0.2 Who is this book for?", " 0.2 Who is this book for? We hope this book will be a useful introduction for anyone who wants to learn how to use R. It started out as a 100 page pdf manual used to support our teaching in numerous undergraduate and postgraduate biostatistics classes at the University of Aberdeen and has evolved over the last 10 years to the book you are now reading. Consequently, this book is primarily written with the advanced undergraduate or postgraduate student in mind although the material should be useful for anyone with an interest in learning R regardless of background. Our book assumes that you have no previous experience of using either R or RStudio and no background in programming or using command-line interface software. We have also tried to make the content of this book operating system agnostic and have included information for Windows, Mac and Linux users where appropriate. "],
["why-an-open-book.html", "0.3 Why an open book?", " 0.3 Why an open book? We decided to write this book as a freely available open source document for a number of reasons. Firstly, we hope this book will be a living document that naturally evolves over time. As such, if you find any errors in the book or want to make a suggestion on how to improve it, please open an issue on the GitHub site. If you want to take a peek at all the code behind the book visit the book GitHub repo. If you feel like contributing to the book, please get in touch, we would be happy to hear from you. Secondly, the release of the bookdown package by Yihui Xie has made it incredibly easy to collaboratively write, update and maintain this book using RMarkdown and RStudio. Without the bookdown package this book wouldn’t exist in its current format. Lastly, R is not just software, it’s also a wonderful open community with many thousands of contributors all working to make R even better. This is our small contribution. "],
["who-are-we.html", "0.4 Who are we?", " 0.4 Who are we? TODO "],
["book-website.html", "0.5 Book website", " 0.5 Book website Although you can use this book as a standalone resource, we recommend you use it in conjunction with the companion website. The course website contains a series of exercises which will help you practice writing R code and test your understanding of key concepts - you certainly won’t learn how to use R by watching other people do it (or reading a book about it!). The website also contains solutions for each of the exercises and a plethora of links to additional tutorials and resources. "],
["some-r-pointers.html", "0.6 Some R pointers", " 0.6 Some R pointers A question we get asked fairly regularly is ‘what’s the best/easiest way to learn R?’. Unfortunately, we don’t have a ready answer to this question as everyone tends to learn R in their own way and at their own pace. Having said that, here are a few things to bear in mind that might help: Use R often and use it regularly - find any excuse to fire up R (or RStudio) and get coding to help build and maintain all important momentum. Learning R is not a memory test. One of the beauties of a scripting language is that you will always have your code to refer back to when you inevitably forget how to do something. You don’t need to know everything there is to know about R to use it productively. If you get stuck, Google it, it’s not cheating and writing a good search query is a skill in itself. Just make sure you check thoroughly that the code you find is doing what you want it to do. If you find yourself staring at code for hours trying to figure out why it’s not working then walk away for a few minutes. I have lost count of the number of times I was able to spot my mistake almost immediately after returning from a short caffeine break. In R there are many ways to tackle a particular problem. If your code doesn’t look like someone elses, but it does what you want it to do in a reasonable time and robustly then don’t worry about it - job done. Related to the previous point, remember R is just a tool to help you answer your interesting questions. Although it can be fun to immerse yourself in all things R, don’t lose sight of what’s important - your research question(s) and your data. No amount of skill using R will help if your data collection is fundamentally flawed or your question vague. Recognise that there will be times when things will get a little tough or frustrating. Try to accept these periods as part of the natural process of learning how to use R (we’ve all been there) and remember, the time and energy you invest now will be more than payed back in the not too distant future. Finally, once you have finished working your way through this book, we encourage you to practice what you’ve learned using your own data. If you don’t have any data yet, then ask your colleagues / friends / family for some (I’m sure they will be delighted!) or follow one of the many excellent tutorials available on-line (see the course website for more details). Our suggestion to you, is that while you are getting to grips with R, uninstall any other statistics software you have on your computer and only use R. This may seem a little extreme but will hopefully remove the temptation to ‘just do it quickly’ in a more familiar environment and consequently slow down your learning of R. Believe us, anything you can do in your existing statistics software package you can do in R - often more robustly and efficiently. Good luck and have don’t forget to have fun. The book is licensed according to the Creative Commons Attribution-NonCommercial 2.0 Generic (CC BY-NC 2.0) License. Please see the terms of that license for more details. "],
["chap1.html", "Chapter 1 Getting started with R and RStudio", " Chapter 1 Getting started with R and RStudio Although R is not new, it’s popularity has increased rapidly over the last 10 years or so (see here for some interesting data). It was originally created and developed by Ross Ihaka and Robert Gentleman during the 1990’s with the first stable version released in 2000. Nowadays R is currently maintained by the R Development Core Team. So, why has R become so popular and why should you learn how to use it? Some reasons include: R is open source and freely available. R is available for Windows, Mac and Linux operating systems. R has an extensive and coherent set of tools for statistical analysis. R has an extensive and highly flexible graphical facility capable of producing publication quality figures. R has an expanding set of freely available ‘packages’ to extend R’s capabilities. R has an extensive support network with numerous online and freely available documents. All of the reasons above are great reasons to use R. However, in our opinion, the single biggest reason to use R is that it facilitates robust and reproducible research practices. In contrast to more traditional ‘point and click’ software, writing R code to perform your analysis ensures you have a permanent and accurate record of all the methods you used (and decisions you made) whilst analysing your data. You are then able to share this code (and your data) with other researchers / colleagues / journal reviewers who will be able to reproduce your analysis exactly. This is one of the tenets of open science. We will cover other topics to facilitate open science throughout this book, including creating reproducible reports and version control. In this Chapter we’ll cover downloading and installing R and RStudio on your computer, a brief RStudio orientation including working with RStudio Projects, installing and working with R packages to extend R’s capabilities, some good habits to get into when working on projects and with files and finally some advice on documenting your workflow and writing nice R code. "],
["install-r.html", "1.1 Installing R", " 1.1 Installing R To get up and running the first thing you need to do is install R. R is freely available for Windows, Mac and Linux operating systems from the Comprehensive R Archive Network (CRAN) website. For Windows and Mac users we suggest you download and install the precompiled binary versions. 1.1.1 Windows users For Windows users select ‘Download R for Windows’ link and then click on the ‘base’ link and finally the download link ‘Download R 3.X.X for Windows’ (where 3.X.X is the latest version of the binary - 3.6.1 at the time of writing). This will begin the download of the ‘.exe’ installation file. When the download has completed double click on the R executable file and follow the on-screen instructions. Full installation instructions can be found at the CRAN website. 1.1.2 Mac users For Mac users select the ‘Download R for (Mac) OS X’ link. The binary can be downloaded by selecting the ‘R-3.X.X.pkg’ (R-3.6.1.pkg at the time of writing). Once downloaded, double click on the file icon and follow the on-screen instructions to guide you through the necessary steps. See the ‘R for Mac OS X FAQ’ for further information on installation. 1.1.3 Linux users For Linux users, the installation method will depend on which flavour of Linux you are using. There are reasonably comprehensive instruction here for Debian, Redhat, Suse and Ubuntu. In most cases you can just use your OS package manager to install R from the official repository. On Ubuntu fire up a shell (Terminal) and use (you will need root permission to do this): sudo apt update sudo apt install r-base r-base-dev which will install base R and also the development version of base R (you only need this if you want to compile R packages from source but it doesn’t hurt to have it). If you receive an error after running the code above you may need to add a ‘source.list’ entry to your etc/apt/sources.list file. To do this open the /etc/apt/sources.list file in your favourite text editor (gedit, vim, nano etc) and add the following line (you will need root permission to do this): deb https://cloud.r-project.org/bin/linux/ubuntu disco-cran35/ This is the source.list for the latest version of Ubuntu (19.04 Disco Dingoat the time of writing). If you’re using an earlier version of Ubuntu then replace the source.list entry to the one which corresponds to the version of Ubuntu you are using (see here for an up to date list). Once you have done this then re-run the apt commands above and you should be good to go. 1.1.4 Testing R Whichever operating system you’re using, once you have installed R you need to check its working properly. The easiest way to do this is to start R by double clicking on the R icon (Windows or Mac) or by typing R into the console (Linux). You should see the R console and you should be able to type R commands into the console. Try typing the following R code and then press enter (don’t worry of you don’t understand this - we’re just checking if R works) A plot of the numbers 1 to 10 on both the x and y axes should appear. If you see this, you’re good to go. If not then we suggest you make a note of any errors produced and then use Google to troubleshoot). plot(1:10) Figure 1.1: plot to test R installation "],
["installing-rstudio.html", "1.2 Installing RStudio", " 1.2 Installing RStudio Whilst its eminently possible to just use the base installation of R (many people do), we will be using a popular Integrated Development Environment (IDE) called RStudio. RStudio can be thought of as an add-on to R which provides a more user-friendly interface, incorporating the R console, script editor and other useful functionality (like R markdown and Git Hub integration). You can find more information about RStudio here. RStudio is freely available for Windows, Mac and Linux operating systems and can be downloaded from the RStudio site. You should select the ‘RStudio Desktop’ version. Note: you must install R before you install RStudio (see previous section for details). 1.2.1 Windows and Mac users For Windows and Mac users you should be presented with the appropriate link for downloading. Click on this link and once downloaded run the installer and follow the instructions. If you don’t see the link then scroll down to the ‘All Installers’ section and choose the link manually. 1.2.2 Linux users For linux users** scroll down to the ‘All Installers’ section and choose the appropriate link to download the binary for your Linux operating system. RStudio for Ubuntu (and Debian) is available as a *.deb package. The easiest way to install deb files on Ubuntu is by using the gdebi command. If gdebi is not available on your system you can install it by using the following command in the Terminal (you will need root permission to do this) sudo apt update sudo apt install gdebi-core To install the *.deb file navigate to where you downloaded the file and then enter the following command with root permission sudo gdebi rstudio-xenial-1.2.5XXX-amd64.deb where ‘-1.2.5XXX’ is the current version for Ubuntu (rstudio-xenial-1.2.5019-amd64.deb at the time of writing). You can then start RStudio from the console by simply typing rstudio or you can create a shortcut on your Desktop for easy startup. 1.2.3 Testing RStudio Once installed, you can check everything is working by starting up RStudio (you don’t need to start R as well, just RStudio). You should see something like the image below Figure 1.2: RStudio on Mac OS X "],
["rstudio-orient.html", "1.3 RStudio orientation", " 1.3 RStudio orientation When you open R studio for the first time you should see the following layout (itmight look slightly different on a Windows computer) The large window (aka pane) on the left is the Console window. The window on the top right is the Environment / History / Files pane and the bottom left window is the Plots / Help / Viewer window. We will discuss each of these panes in turn below. You can customise the location of each pane by clicking on the ‘Tools’ menu then selecting Global Options –&gt; Pane Layout. You can resize the panes by clicking and dragging the middle of the window borders in the direction you want. There are a plethora of other ways to [customise RStudio][rstudio-customise]. 1.3.1 Console The console is the workhorse of R. This is where R evaluates all the code you write and stores all the objects (data for example) you create. You can type R code directly into the console at the command line prompt, &gt;. For example, if you type 2 + 2 into the console you should obtain the answer 4 (reassuringly). Don’t worry about the [1] at the start of the line for now. However, once you start writing more R code this becomes rather cumbersome. Instead of typing R code directly into the console a better approach is to create an R script. An R script is just a plain text file with a .R file extension which contains your lines of R code. These lines of code are then sourced into the R console line by line. To create a new R script click on the ‘File’ menu then select New File –&gt; R Script. Notice that you have a new window (called the Source pane) in the top left of RStudio and the console is now in the bottom left position. The new window is a script editor and where you will write your code. To source your code from your script editor to the console simply place your cursor on the line of code and then click on the ‘Run’ button in the top right of the script editor pane. You should see the result in the console window. If clicking on the ‘Run’ button starts to become tiresome you can use the keyboard shortcut ‘ctrl + enter’ (on Windows and Linux) or ‘cmd + enter’ (on Mac). You can save your R scripts as a .R file by selecting the ‘File’ menu and clicking on save. Notice that the file name in the tab will turn red to remind you that you have unsaved changes. To open your R script in RStudio select the ‘File’ menu and then ‘Open File…’. Finally, its worth noting that although R scripts are saved with a .R extension they are actually just plain text files which can be opened with any text editor. 1.3.2 Environment / History / Connections The Environment / History / Connections window shows you lots of useful information. You can access each component by clicking on the appropriate tab in the pane. The ‘Environment’ tab displays all the objects you have created in the current (global) environment. These objects can be things like data you have imported or functions you have written. Objects can be displayed as a List or in Grid format by selecting your choice from the drop down button on the top right of the window. If you’re in the Grid format you can remove objects from the environment by placing a tick in the empty box next to the object name and then click on the broom icon. There’s also an ‘Import Dataset’ button which will import data saved in a variety of file formats. However, we would suggest that you don’t use this approach to import your data as it’s not reproducible and therefore not robust (see Chapter 3 for more details). The ‘History’ tab contains a list of all the commands you have entered into the R console. You can search back through your history for the line of code you have forgotten, send selected code back to the console or Source window. We usually never use this as we always refer back to our R script. 1.3.3 Files / Plots / Packages / Help / Viewer The ‘Files’ tab lists all external files and directories in the current working directory on your computer. It works like file explorer (Windows) or Finder (Mac). You can open, copy, rename, move and delete files listed in the window. The ‘Plots’ tab is where all the plots you create in R are displayed (unless you tell R otherwise). You can ‘zoom’ into the plots to make them larger and scroll back through previously created plots using the arrow buttons. There is also the option of exporting plots to an external file using the ‘Export’ drop down menu. Plots can be exported in various file formats such as jpeg, png, pdf, tiff or copied to the clipboard (although you are probably better off using the appropriate R functions to do this - see Chapter 4 for more details). The ‘Help’ tab displays the R help documentation for any function. We will go over how to view the help files and how to search for help in Chapter 2. The ‘Viewer’ tab displays local web content such as web graphics generated by some packages. "],
["alternatives-to-rstudio.html", "1.4 Alternatives to RStudio", " 1.4 Alternatives to RStudio Although RStudio is becoming increasingly popular it might not be the best choice for everyone and you certainly don’t have to use it to use R effectively. Rather than using an ‘all in one’ IDE many people choose to use R and a separate script editor to write and execute R code. If you’re not familiar with what a script editor is, you can think of it as a bit like a word processor but specifically designed for writing code. Happily, there are many script editors freely available so feel free to download and experiment until you find one you like. Some script editors are only available for certain operating systems and not all are specific to R. Suggestions for script editors are: For windows users Tinn-R Atom Notepad++ For Mac users TextMate Atom MacVim For Linux users gedit (comes with Ubuntu already) Atom vim/nano (console based editors) Which one you choose is up to you. One of the great things about R is that YOU get to choose how you want to use R "],
["r-packages.html", "1.5 R packages", " 1.5 R packages The base installation of R comes with many useful packages as standard. These packages will contain many of the functions you will use on a daily basis. However, as you start using R for more diverse projects (and as your own use of R evolves) you will find that there comes a time when you will need to extend R’s capabilities. Happily, many thousands of R users have developed useful code and shared this code as installable packages. You can think of a package as a collection of functions, data and help files collated into a well defined standard structure which you can download and install in R. These packages can be downloaded from a variety of sources but the most popular are CRAN, Bioconductor and GitHub. Currently, CRAN hosts over 15000 packages and is the official repository for user contributed R packages. Bioconductor provides open source software oriented towards bioinformatics and hosts over 1800 R packages. GitHub is a website that hosts git repositories for all sorts of software and projects (not just R). Often, cutting edge development versions of R packages are hosted on GitHub so if you need all the new bells and whistles then this may be an option. However, a potential downside of using the development version of an R package is that it might not be as stable as the version hosted on CRAN (it’s in development!) and updating packages won’t be automatic. 1.5.1 CRAN packages To install a package from CRAN you can use the install.packages() function. For example if you want to install the remotes package enter the following code into the console window of RStudio (note: you will need a working internet connection to do this) install.packages(&#39;remotes&#39;, dependencies = TRUE) You may be asked to select a CRAN mirror, just select ‘0-cloud’ or a mirror near to your location. The dependencies = TRUE argument ensures that additional packages that are required will also be installed. It’s good practice to occasionally update your previously installed packages to get access to new functionality and bug fixes. To update CRAN packages you can use the update.packages() function (you will need a working internet connection for this) update.packages(ask = FALSE) The ask = FALSE argument avoids having to confirm every package download which can be a pain if you have many packages installed. 1.5.2 Bioconductor packages To install packages from Bioconductor the process is a little different. You first need to install the BiocManager package. You only need to do this once unless you subsequently reinstall or upgrade R install.packages(&#39;BiocManager&#39;, dependencies = TRUE) Once the BiocManager package has been installed you can either install all of the ‘core’ Bioconductor packages with BiocManager::install() or install specific packages such as the ‘GenomicRanges’ and ‘edgeR’ packages BiocManager::install(c(&quot;GenomicRanges&quot;, &quot;edgeR&quot;)) To update Bioconductor packages just use the BiocManager::install() function again BiocManager::install(ask = FALSE) Again, you can use the ask = FALSE argument to avoid having to confirm every package download. 1.5.3 GitHub packages There are multiple options for installing packages hosted on GitHub. Perhaps the most efficient method is to use the install_github() function from the remotes package (you installed this package previously). Before you use the function you will need to know the GitHub username of the repository owner and also the name of the repository. For example, the development version of dplyr from Hadley Wickham is hosted on the tidyverse GitHub account and has the repository name ‘dplyr’ (just Google ‘github dplyr’). To install this version form GitHub use remotes::install_github(&#39;tidyverse/dplyr&#39;) The safest way (that we know of) to update a package installed from GitHub is to just reinstall it using the above command. 1.5.4 Using packages Once you have installed a package onto your computer it is not immediately available for you to use. To use a package you first need to load the package by using the library() function. For example, to load the devtools package you previously installed library(devtools) The library() function will also load any additional packages required and may print out additional package information. It is important to realise that every time you start a new R session (or restore a previously saved session) you need to load the packages you will be using. We tend to put all our library() statements required for our analysis near the top of our R scripts to make them easily accessible and easy to add to as our code develops. If you try to use a function without first loading the relevant R package you will receive an error message that R could not find the function. For example, if you try to use the install_gitgub() function without loading the devtools package first you will receive the following error install_github(&#39;tidyverse/dplyr&#39;) # Error in install_github(&quot;tidyverse/dplyr&quot;) : # could not find function &quot;install_github&quot; Sometimes it can be useful to use a function without first using the library() function. If, for example, you will only be using one or two functions in your script and don’t want to load all of the other functions in a package then you can access the function directly by specifying the package name followed by two colons and then the function name devtools::install_github(&#39;tidyverse/dplyr&#39;) This is how we were able to use the install() and install_github() functions above without first loading the packages BiocManager and devtools. Most of the time we recommend using the library() function. As with most things in life, when it comes to dealing with data and data analysis things are so much simpler if you’re organised. Clear project organisation makes it easier for both you (especially the future you) and your collaborators to make sense of what you’ve done. There’s nothing more frustrating than coming back to a project months (sometimes years) later and have to spend days (or weeks) figuring out where everything is, what you did and why you did it. A well documented project that has a consistent and logical structure increases the likelihood that you can pick up where you left off with minimal fuss no matter how much time has passed. In addition, it’s much easier to write code to automate tasks when files are well organised and are sensibly named. This is even more relevant nowadays as it’s never been easier to collect vasts amount of data which can be saved across 1000’s or even 100,000’s of separate data files. Lastly, having a well organised project reduces the risk of introducing bugs or errors into your workflow and if they do occur (which inevitably they will at some point), it makes it easier to track down these errors and deal with them efficiently. Thankfully, there are some nice features in R and RStudio that make it quite easy to manage a project. There are also a few simple steps you can take right at the start of any project to help keep things shipshape. "],
["rsprojs.html", "1.6 Projects in RStudio", " 1.6 Projects in RStudio As with most things in life, when it comes to dealing with data and data analysis things are so much simpler if you’re organised. Clear project organisation makes it easier for both you (especially the future you) and your collaborators to make sense of what you’ve done. There’s nothing more frustrating than coming back to a project months (sometimes years) later and have to spend days (or weeks) figuring out where everything is, what you did and why you did it. A well documented project that has a consistent and logical structure increases the likelihood that you can pick up where you left off with minimal fuss no matter how much time has passed. In addition, it’s much easier to write code to automate tasks when files are well organised and are sensibly named. This is even more relevant nowadays as it’s never been easier to collect vasts amount of data which can be saved across 1000’s or even 100,000’s of separate data files. Lastly, having a well organised project reduces the risk of introducing bugs or errors into your workflow and if they do occur (which inevitably they will at some point), it makes it easier to track down these errors and deal with them efficiently. Thankfully, there are some nice features in R and RStudio that make it quite easy to manage a project. There are also a few simple steps you can take right at the start of any project to help keep things shipshape. A great way of keeping things organised is to use RStudio Projects. An RStudio Project keeps all of your R scripts, R markdown documents, R functions and data together in one place. The nice thing about RStudio Projects is that each project has its own directory, workspace, history and source documents so different analyses that you are working on are kept completely separate from each other. This means that you can have multiple instances of RStudio open at the same time (if that’s your thing) or you can switch very easily between projects without fear of them interfering with each other. To create a project, open RStudio and select File -&gt; New Project... from the menu. You can create either an entirely new project, a project from an existing directory or a version controlled project (see the GitHub Chapter for further details about this). In this Chapter we will create a project in a new directory. You can also create a new project by clicking on the ‘Project’ button in the top right of RStudio and selecting ‘New Project…’ In the next window select ‘New Project’. Now enter the name of the directory you want to create in the ‘Directory name:’ field (we’ll call it first_project for this Chapter). If you want to change the location of the directory on your computer click the ‘Browse…’ button and navigate to where you would like to create the directory. I always tick the ‘Open in new session’ box as well. Finally, hit the ‘Create Project’ to create the new project. Once your new project has been created you will now have a new folder on your computer that contains an RStudio project file called first_project.Rproj. This .Rproj file contains various project options (but you shouldn’t really interact with it) and can also be used as a shortcut for opening the project directly from the file system (just double click on it). You can check this out in the ‘Files’ tab in RStudio (or in Finder if you’re on a Mac or File Explorer in Windows). The last thing I suggest you do is select Tools -&gt; Project Options... from the menu. Click on the ‘General’ tab on the left hand side and then change the values for ‘Restore .RData into workspace at startup’ and ‘Save workspace to .RData on exit’ from ‘Default’ to ‘No’. This ensures that every time you open your project you start with a clean R session. You don’t have to do this (many people don’t) but I prefer to start with a completely clean workspace whenever I open my projects to avoid any potential conflicts with things I did in previous sessions. The downside to this is that you will need to rerun your R code every time you open you project. Now that you have an RStudio project set up you can start creating R scripts (or R markdown documents) or whatever you need to complete you project. All of the R scripts will now be contained within the RStudio project and saved in the project folder. "],
["working-directories.html", "1.7 Working directories", " 1.7 Working directories The working directory is the default location where R will look for files you want to load and where it will put any files you save. One of the great things about using RStudio Projects is that when you open a project it will automatically set your working directory to the appropriate location. You can check the file path of your working directory by looking at bar at the top of the Console pane. Note: the ~ symbol above is shorthand for /Users/nhy163/ on my Mac computer (the same on Linux computers). You can also use the getwd() function in the Console which returns the file path of the current working directory. In the example above, my working directory is a folder called ‘first_project’ which is a subfolder of &quot;Teaching’ in my ‘Alex’ folder which in turn is in a ‘Documents’ folder located in the ‘nhy163’ folder which itself is in the ‘Users’ folder. On a Windows based computer my working directory would also include a drive letter (i.e. C:/Users/nhy163/Documents/Alex/Teaching/first_project). If you weren’t using an RStudio Project then you would have to set your working directory using the setwd() function at the start of every R script (something I did for many years). setwd(&#39;/Users/nhy163/Documents/Alex/Teaching/first_project&#39;) However, the problem with setwd() is that it uses an absolute file path which is specific to the computer you are working on. If you want to send your script to someone else (or if you’re working on a different computer) this absolute file path is not going to work on your friend/colleagues computer as their directory configuration will be different (you are unlikely to have a directory structure /Users/nhy163/Documents/Alex/Teaching/ on your computer). This results in a project that is not self-contained and not easily portable. RStudio solves this problem by allowing you to use relative file paths which are relative to the Root project directory. The Root project directory is just the directory that contains the .Rproj file (first_project.Rproj in our case). If you want to share your analysis with someone else, all you need to do is save the entire project directory and send to your to your collaborator. They would then just need to open the project file and any R scripts that contain references to relative file paths will just work. For example, let’s say that you’ve created a subdirectory called raw_data in your Root project directory that contains a tab delimited datafile called mydata.txt (we will cover directory structures below). To import this datafile in an RStudio project all you need to include in your R script is dataf &lt;- read.table(&#39;raw_data/mydata.txt&#39;, header = TRUE, sep = &#39;\\t&#39;) Because the file path raw_data/mydata.txt is relative to the project directory it doesn’t matter where you collaborator saves the project directory on their computer it will still work. If you weren’t using an RStudio project then you would have to use either of the options below neither of which would work on a different computer. setwd(&quot;/Users/nhy163/Documents/Alex/Teaching/first_project/&quot;) dataf &lt;- read.table(&quot;raw_data/mydata.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # or dataf &lt;- read.table(&quot;/Users/nhy163/Documents/Alex/Teaching/first_project/raw_data/mydata.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) For those of you who want to take the notion of relative file paths a step further, take a look at the here() function in the here package. The here() function allows you to automagically build file paths for any file relative to the project root directory that are also operating system agnostic (works on a Mac or Windows machine). For example, to import our mydata.txt file from the raw_data directory just use library(here) # you may need to install the here package first dataf &lt;- read.table(here(&quot;raw_data&quot;, &quot;mydata.txt&quot;), header = TRUE, sep = &#39;\\t&#39;) # or without loading the here package dataf &lt;- read.table(here::here(&quot;raw_data&quot;, &quot;mydata.txt&quot;), header = TRUE, sep = &#39;\\t&#39;) "],
["directory-structure.html", "1.8 Directory structure", " 1.8 Directory structure In addition to using RStudio Projects, it’s also really good practice to structure your directory in a consistent and logical way to help both you and your collaborators. I frequently use the following directory structure in my R based projects Root | |__data | |__raw_data | |__processed_data | |__metadata |__R |__Rmd |__scripts |__output In my working directory I have the following directories: Root - This is your project directory containing your .Rproj file. data - I store all my data in this directory. The subdirectory called raw_data contains raw data files and only raw data files. These files should be treated as read only and should not be changed in any way. If you need to process/clean/modify your data do this in R (not MS Excel) as you can document (and justify) any changes made. Any processed data should be saved to a separate file and stored in the processed_data subdirectory. Information about data collection methods, details of data download and any other useful metadata should be saved in a text document (see README text files below) in the metadata subdirectory. R - This is an optional directory where I save all of my custom R functions I have written for the current analysis. These can then be sourced into R using the source() function. Rmd - An optional directory where I save my R markdown documents. scripts - All of the main R scripts I have written for the current project are saved here. output - Outputs from my R scripts such as plots, HTML files and data summaries are saved in this directory. This helps me and my collaborators distinguish what files are outputs and which are source files. Of course, the structure described above is just what works for me most of the time and should be viewed as a starting point for your own needs. I tend to have a fairly consistent directory structure across my projects as this allows me to quickly orientate myself when I return to a project after a while. Having said that, different projects will have different requirements so I happily add and remove directories as required. You can create your directory structure using Windows Explorer (or Finder on a Mac) or within RStudio by clicking on the ‘New folder’ button in the ‘Files’ pane. An alternative approach is to use the dir.create() function in the R Console # create directory called &#39;data&#39; dir.create(&#39;data&#39;) # create subdirectory raw_data in the data directory dir.create(&#39;data/raw_data&#39;) # list the files and directories list.files(recursive = TRUE, include.dirs = TRUE) # [1] &quot;data&quot; &quot;data/raw_data&quot; &quot;first_project.Rproj&quot; "],
["file-names.html", "1.9 File names", " 1.9 File names What you call your files matters more than you might think. Naming files is also more difficult than you think. The key requirement for a ‘good’ file name is that it’s informative whilst also being relatively short. This is not always an easy compromise and often requires some thought. Ideally you should try to avoid the following! Figure 1.3: source:https://xkcd.com/1459/ Although there’s not really a recognised standard approach to naming files (actually there is, just not everyone uses it), there are a couple of things to bear in mind. First, avoid using spaces in file names by replacing them with underscores or even hyphens. Why does this matter? One reason is that some command line software (especially many bioinformatic tools) won’t recognise a file name with a space and you’ll have to go through all sorts of shenanigans using escape characters to make sure spaces are handled correctly. Even if you don’t think you will ever use command line software you may be doing so indirectly. Take R markdown for example, if you want to render an R markdown document to pdf using the rmarkdown package you will actually be using a command line LaTeX engine under the hood. Another good reason not to use spaces in file names is that it makes searching for file names (or parts of file names) using regular expressions in R (or any other language) much more difficult. For the reasons given above, avoid using special characters (i.e. @£$%^&amp;*():;&lt;&gt;?{}/) in your file names. If you are versioning your files with sequential numbers (i.e. file1, file2, file3 …) and you have more than 9 files you should use 01, 02, 03 .. 10 as this will ensure the files are printed in the correct order (see what happens if you don’t). If you have more than 99 files then use 001, 002, 003 …etc. If your file names include dates, use the ISO 8601 format YYYY-MM-DD (or YYYYMMDD) to ensure your files are sorted in proper chronological order. Never use the word final in any file name - it never is! Whatever file naming convention you decide to use, try to adopt early, stick with it and be consistent. You’ll thank me! "],
["project-documentation.html", "1.10 Project documentation", " 1.10 Project documentation A quick note or two about writing R code and creating R scripts. Unless you’re doing something really quick and dirty I suggest that you always write your R code as an R script. R scripts are what make R so useful. Not only do you have a complete record of your analysis, from data manipulation, visualisation and statistical analysis, you can also share this code (and data) with friends, colleagues and importantly when you submit and publish your research to a journal. With this in mind, make sure you include in your R script all the information required to make your work reproducible (author names, dates, sampling design etc). This information could be included as a series of comments # or, even better, by mixing executable code with narrative into an R markdown document. It’s also good practice to include the output of the sessionInfo() function at the end of any script which prints the R version, details of the operating system and also loaded packages. Here is an example of including meta-information at the start of an R script # Title: Time series analysis of snouters # Purpose : This script performs a time series analyses on snouter count data. # Data consists of counts of snouter species collected from 18 islands # in the Hy-yi-yi archipelago between 1950 and 1957. # For details of snouter biology see: # https://en.wikipedia.org/wiki/Rhinogradentia # Project number: #007 # Data file: &#39;/Users/Another/snouter_analysis/snouter_pop.txt&#39; # Author: A. Nother # Contact details: a.nother@uir.ac.uk # Date script created: Mon Dec 2 16:06:44 2019 ------------------------------ # Date script last modified: Thu Dec 12 16:07:12 2019 ---------------------- # package dependencies library(PopSnouter) library(ggplot2) print(&#39;put your lovely R code here&#39;) # good practice to include sessionInfo sessionInfo() This is just one example and there are no hard and fast rules so feel free to develop a system that works for you. A really useful shortcut in RStudio is to automatically include a time and date stamp in your R script. To do this, write ts where you want to insert your time stamp in your R script and then press the ‘shift + tab’ keys. RStudio will magically convert ts into the current date and time and also automatically comment out this line with a #. Another really useful RStudio shortcut is to comment out multiple lines in your script with a # symbol. To do this, highlight the lines of text you want to comment and then press ‘ctrl + shift + c’. To uncomment the lines just use ‘ctrl + shift + c’ again. In addition to including metadata in your R scripts it’s also common practice to create a separate text file to record important information. By convention these text files are named README. I often include a README file in the directory where I keep my raw data. In this file I include details about when data were collected (or downloaded), how data were collected, information about specialised equipment, preservation methods, type and version of any machines used (i.e. sequencing equipment) etc. You can create a README file for your project in RStudio by clicking on the File -&gt; New File -&gt; Text File menu. "],
["r-style-guide.html", "1.11 R style guide", " 1.11 R style guide How you write your code is more or less up to you although your goal should be to make it as easy to read as possible (for you and others). Whilst there are no rules (and no code police), I encourage you to get into the habit of writing readable R code by adopting a particular style. I suggest that you follow Google’s R style guide whenever possible. This style guide will help you decide where to use spaces, how to indent code and how to use square [ ] and curly { } brackets amongst other things. If all that sounds like too much hard work you can install the styler package which includes an RStudio add-in to allow you to automatically restyle selected code (or entire files and projects) with the click of your mouse. You can find more information about the styler package including how to install here. Once installed, you can highlight the code you want to restyle, click on the ‘Addins’ button at the top of RStudio and select the ‘Style Selection’ option. Here is an example of poorly formatted R code Now highlight the code and use the styler package to reformat To produce some nicely formatted code "],
["backing-up-projects.html", "1.12 Backing up projects", " 1.12 Backing up projects Don’t be that person who loses hard won (and often expensive) data and analyses. Don’t be that person who thinks it’ll never happen to me - it will! Always think of the absolute worst case scenario, something that makes you wake up in a cold sweat at night, and do all you can to make sure this never happens. Just to be clear, if you’re relying on copying your precious files to an external hard disk or USB stick this is NOT an effective backup strategy. These things go wrong all the time as you lob them into your rucksack or ‘bag for life’ and then lug them between your office and home. Even if you do leave them plugged into your computer what happens when the building burns down (I did say worst case!)? Ideally, your backups should be offsite and incremental. Happily there are numerous options for backing up your files. The first place to look is in your own institute. Most (all?) Universities have some form of network based storage that should be easily accessible and is also underpinned by a comprehensive disaster recovery plan. Other options include cloud based services such as Google Docs and Dropbox (to name but a few), but make sure you’re not storing sensitive data on these services and are comfortable with the often eye watering privacy policies. Whilst these services are pretty good at storing files, they don’t really help with incremental backups. Finding previous versions of files often involves spending inordinate amounts of time trawling through multiple files named ‘final.doc’, ‘final_v2.doc’ and ‘final_usethisone.doc’ etc until you find the one you were looking for. The best way I know for both backing up files and managing different versions of files is to use Git and GitHub. To find out more about how you can use RStudio, Git and GitHub together see the Git and GitHub Chapter. "],
["basics-r.html", "Chapter 2 Some R basics", " Chapter 2 Some R basics In this Chapter we’ll introduce you to using R and RStudio to perform some basic R tasks such as creating variables and assigning values to variables, exploring different types of variables and how to perform some common operations on variables. We’ll also learn how to get help in R and highlight some resources to help support your R learning. Finally, we’ll cover how to save your work. Before we continue, here are a few things to bear in mind as you work through this Chapter: R is case sensitive i.e. A is not the same as a and anova is not the same as Anova. Anything that follows a # symbol is interpreted as a comment and ignored by R. Comments should be used liberally throughout your code for both your own information and also to help your collaborators. Writing comments is a bit of an art and something that you will become more adept at as your experience grows. In R, commands are generally separated by a new line. You can also use a semicolon ; to separate your commands but this is rarely used. If a continuation prompt + appears after you execute your code this means that you haven’t completed your code correctly. This often happens if you forget to close a bracket and is especially common when nested brackets are used ((((some command))). Just finish the command on the new line and fix the typo or hit escape on your keyboard (see point below) and fix. In general, R is fairly tolerant of extra spaces inserted into your code, in fact using spaces is actively encouraged. However, spaces should not be inserted into operators i.e. &lt;- should not read &lt; - (note the space). See Google’s style guide for advice on where to place spaces to make your code more readable. If your console ‘hangs’ and becomes unresponsive after running a command you can often get yourself out of trouble by pressing the escape key (esc) on your keyboard or clicking on the stop icon in the top right of your console. This will terminate most current operations. "],
["getting-started.html", "2.1 Getting started", " 2.1 Getting started In Chapter 1 we learned about the R Console and creating scripts and Projects in RStudio. We also saw how you write your R code in a script and then source this code into the console to get it to run (if you’ve forgotten how to do this, pop back to the console section to refresh your memory). Writing your code in a script means that you’ll always have a permanent record of everything you’ve done (provided you save for script) and also allows you to make loads of comments to remind your future self what you’ve done. So, while you’re working through this Chapter we suggest that you create a new script (or RStudio Project) to write your code as you follow along. You can find a copy of an example script for this Chapter here TODO As we saw in the previous Chapter, at a basic level we can use R much as you would use a calculator. We can type an arithmetic expression into our script, then source it into the console and receive a result. For example, if we type the expression 2 + 2 and then source this line of code we get the answer 4 (reassuringly!) 2 + 2 # [1] 4 The [1] in front of the result tells you that the observation number at the beginning of the line is the first observation. This is not much help in this example, but can be quite useful when printing results with multiple lines (we’ll see an example below). The other obvious arithmetic operators are -, *, / for subtraction, multiplication and division respectively. R follows the usual mathematical convention of order of operations. For example, the expression 2 + 3 * 4 is interpreted to have the value 2 + (3 * 4) = 14, not (2 + 3) * 4 = 20. There are a huge range of mathematical functions in R, some of the most useful include log(1) # logarithm to base e # [1] 0 log10(1) # logarithm to base 10 # [1] 0 exp(1) # natural antilog # [1] 2.72 sqrt(4) # square root # [1] 2 4^2 # 4 to the power of 2 # [1] 16 pi # not a function but useful # [1] 3.14 It’s important to realise that when you run code as we’ve done above, the result of the code (or value) is only displayed in the console. Whilst this can sometimes be useful it is usually much more practical to store the value(s) in a object. "],
["objects-in-r.html", "2.2 Objects in R", " 2.2 Objects in R At the heart of almost everything you will do (or ever likely do) in R is the concept that everything in R is an object. These objects can be almost anything, from a single number or character string (like a word) to highly complex structures like the output of a plot, a summary of your statistical analysis or a set of R commands that perform a specific task. Understanding how you create objects and assign values to objects is key to understanding R. To create an object we simply give the object a name. We can then assign a value(s) to this object using the assignment operator &lt;- (sometimes called the gets). The assignment operator is a composite symbol comprised of a ‘less than’ symbol &lt; and a hyphen - . For example my_obj &lt;- 48 In the code above, we created an object called my_obj and assigned it a value of the number 48 using the assignment operator (in my head I always read this as my_obj gets 48). You can also use = instead of &lt;- to assign values but this is considered bad practice and we would discourage you from using this notation. To view the value of the object you simply type the name of the object my_obj # [1] 48 Now that we’ve created this object, R knows all about it and will keep track of it during this current R session. All of the objects you create will be stored in the current workspace and in RStudio you can view all the objects in your workspace by clicking on the ‘Environment’ tab in the right hand pane If you click on the down arrow on the ‘List’ icon in the same pane and change to ‘Grid’ view RStudio will show you a summary of the objects including the type (numeric - it’s a number), the length (only one value in this object), its ‘physical’ size and its value (48 in this case). There are many different types of values that you can assign to an object. For instance my_obj2 &lt;- &quot;R is cool&quot; Here we have created an object called my_obj2 and assigned it a value of the R is cool which is a character string. Notice that we have enclosed the string in quotes. If you forget to use the quotes you will receive an error message my_obj2 &lt;- R is cool Error: unexpected symbol in &quot;my_obj2 &lt;- R is&quot; Our workspace now contains the two objects we have created with my_obj2 is listed as type character. We will return to the different classes of objects throughout this book. To change the value of an existing object we simple reassign our new value to it. For example to change the value of my_obj2 from R is cool to the number 1024 my_obj2 &lt;- 1024 Notice that the Type has changed to numeric and the value has changed to 1024 in the workspace Naming your objects is one of the most difficult things you will do in R (honestly - I’m serious). Ideally your object names should be kept short and informative (not always easy). If you need to create objects with multiple words use either an underscore, dot or capitalise the different words output_summary &lt;- &quot;my analysis&quot; output_summary &lt;- &quot;my analysis&quot; outputSummary &lt;- &quot;my analysis&quot; There are also a few limitations when it come to giving objects names. An object name cannot start with a number or a dot followed by a number (i.e. .2myvariable). Also, make sure you don’t name your objects with reserved words (i.e. TRUE, NA) and it’s never a good idea to give your variable the same name as a built-in function. One that crops up more times than I can remember is data &lt;- read.table(&quot;mydatafile&quot;, header = TRUE) # data is a function! "],
["vectors-in-r.html", "2.3 Vectors in R", " 2.3 Vectors in R vectors extracting, sorting and ordering "],
["getting-help.html", "2.4 Getting help", " 2.4 Getting help 2.4.1 R help 2.4.2 Other sources of help "],
["saving-in-r.html", "2.5 Saving in R", " 2.5 Saving in R vectors extracting, sorting and ordering "],
["data-r.html", "Chapter 3 Data in R", " Chapter 3 Data in R content to follow "],
["graphics-r.html", "Chapter 4 Graphics in R", " Chapter 4 Graphics in R For many people, one of their favourite uses of R is in making figures. These can either take the form of a quick dirty plot to allow you to get a feel for what’s going on in your dataset, or fancier/more complex figures to use in a publication or report. This process is often as close as many analysts/scientists get to having a professional creative side (at least that’s true for me), and it’s something which those folks take great pride in. As stated in the introduction, one of the many reasons for the rise in the popularity of R is due to its ability to produce publication standard figures (as well as those quick and dirty figures - which are the type you and I and everyone else will produce most of). Not only can R users make figures well suited for publication, but producing figures in R allows for lots of customisation, in turn allowing users to create their own particular styles and brands of figures (well beyond the beyond cookie-cutter styles in more traditional point and click programs). Because of this inherent flexibility when producing figures, the data visualisation side of R and supporting packages has grown substantially over the years. In this chapter, we will focus on creating figures through using a specialised package called ggplot2. Before we get going with making some plots of the gg variety, how about a quick little history of one of the most commonly used packages in R? ggplot2 was based on a book called Grammar of Graphics (hence the gg in ggplot2) by Leland Wilkinson yours for only £100 or so. But before you spend all that money, see here for an interesting summary of Wilkinson’s book. Briefly, Wilkinson’s idea (one of them anyway) in grammar of graphics was that figures can be broken down into constituent parts, such as layers (more on this later). While Wilkinson would eventually go on to become vice-president of SPSS, his (and his co-author’s) ideas would, never-the-less, make their way into R via ggplot2. In 2007 ggplot2was officially released by Hadley Wickham. By 2017 the package was said to have been downloaded 10,000,000 times. ggplot2 now has many secondary packages that use it either as a foundation for expanding on or for interfacing with (some statistical packages now have accompanying ggplot2 interfaces for producing figures). It is important to note here that ggplot2 is not required to make “fancy” figures. If you’d prefer to use base R then go ahead. Exactly equivalent figures are possible in base R. The difference betweenggplot2 and base is to do with how you get to the end product rather than any differences in the end product itself. This is, never-the-less, a common belief almost certainly due to the fact that making a moderately attractive figure is easier to do with ggplot2 as many decisions are made for the user, without you necessarily even knowing that a decision was ever made! With that in mind, let’s get started making some figures. "],
["beginning-at-the-end.html", "4.1 Beginning at the end", " 4.1 Beginning at the end The approach I’ll use in this chapter will be to start off by showing you a figure which I reckon is at a standard that you could use in a poster or presentation. Using that as the aim, we will then work towards it step-by-step. You should not view this final figure as any sort of holy grail. For instance, you would be very unlikely to use this in a publication (you’d be much more likely to use some results of your hard earned-analysis). Regardless, this “final figure” is, and will only ever be, a reflection of what my personal preferences are. As with anything subjective, you may well disagree, and to some extent I hope you do. Much better that we all have slightly (or grossly) different views on what a good figure is - otherwise we may as well go back to using cookie-cutter figures. So what is the figure we’re going to make together? Before we go further, let’s take a second and talk about what this figure is showing. On the y axes of the four plots we have the area of the shoot and the x axes we have the weight of a flower. Each column shows the two treatments of the dataset (whether the tip of the flower was cut or not) and the two rows show which block of the greenhouse the plants were grown in (block 1 and block 2). The three colours represent the three nitrogen concentration levels used in the experiment. These colours are used to distinguish which points correspond to nitrogen concentration (also reflected by the shape of the points). Additional to this we have four trend lines. The three nitrogen concentration coloured lines show the trends of shoot area as a function of weight (see chapter 5 for the stats going on behind the scenes). These coloured lines are inturn specific to each “facet” in the grid, changing acording to treatment and block. Additional to the coloured lines is a black dashed line in each facet. These dashed black lines represent the overall relationship (ignoring nitrogen concentration). The final line, the thin dotted grey line, shows the mean shoot area regardless of the weight of the flowers, the treatment or the block. For the purposes of this chapter, we won’t worry about the biology here. Do not take this to be standard, you should absolutely care deeply about the biology in your own data. The biology should be the driving force behind the questions you ask, in turn driving these questions driving the figures that you make. With this figure though, all we care about here is that we are giving the audience lots of information in a relatively readable format. "],
["the-start-of-the-end.html", "4.2 The start of the end", " 4.2 The start of the end The first step in producing a ggplot() is the easiest! We just need to install and then load the package. Use the skills you learnt in Chapter 1.5 to install and load the package. Note that although most people refer to the package as ggplot, it’s proper name is ggplot2. install.packages(&quot;ggplot2&quot;) library(ggplot2) With that taken care of, let’s make our first ggplot()! 4.2.1 The purest of ggplots During the R course that this book is based on, the students are asked at one point to name all of the functions they have either learnt during the course, have heard of or have used before. At this point in the course, the students have not yet learnt about ggplot2, but never-the-less one year a student shouted out ggplot(). When asked what the ggplot() function does, they said that it makes a ggplot. This makes complete and utter sense. So let’s make a ggplot now: ggplot() And here we have it. A fully formed, perfect ggplot. We may have a small issue though. Some puritan data visualisers/plotists/figurines make the claim that figures should include some form of information beyond a light grey background. As loathe as I am to agree with purists, I will do so here. We really should include some data. To do so, we need some data. We’ll keep using the flower dataset that you used in the earlier chapters. Let’s have a quick reminder of what the data looked like. str(flower) # &#39;data.frame&#39;: 96 obs. of 8 variables: # $ treat : Factor w/ 2 levels &quot;notip&quot;,&quot;tip&quot;: 2 2 2 2 2 2 2 2 2 2 ... # $ nitrogen : Factor w/ 3 levels &quot;high&quot;,&quot;low&quot;,&quot;medium&quot;: 3 3 3 3 3 3 3 3 3 3 ... # $ block : int 1 1 1 1 1 1 1 1 2 2 ... # $ height : num 7.5 10.7 11.2 10.4 10.4 9.8 6.9 9.4 10.4 12.3 ... # $ weight : num 7.62 12.14 12.76 8.78 13.58 ... # $ leafarea : num 11.7 14.1 7.1 11.9 14.5 12.2 13.2 14 10.5 16.1 ... # $ shootarea: num 31.9 46 66.7 20.3 26.9 72.7 43.1 28.5 57.8 36.9 ... # $ flowers : int 1 10 10 1 4 9 7 6 5 8 ... We know from the “final figure” that we want shootarea on the y axis and weight on the x axis. To do so in ggplot2 we need to make use of the aes() function and also fulfill the data = argument. aes is short for aesthetics, and it’s the function we use to specify what we want displayed in the figure. If we did not include the aes() function, then the x and y arguments would be ignored. This is a good rule to keep in mind when using ggplot2. The things we want displayed on the figure is included in aes(). All features which alter this displayed information, not based on a variable in our dataset, is included outside of the aes() function. Let’s try it now: # Including aesthetics for x and y axes as well as specifying the dataset ggplot(aes(x = weight, y = shootarea), data = flower) That’s already much better. At least it’s no longer a blank grey canvas. We’ve now told ggplot2 what we want as our x and y axes as well as where to find that data. But what’s missing here is where we tell ggplot2 how to display that data. This is now the time to introduce you to “geoms” or geometric objects. Geoms are the way that ggplot2 displays information. For instance geom_point() tells ggplot2 that you want the information to be displayed as points (making scatterplots possible for example). Given that the “final figure” uses points, this is clearly the appropriate geom to use here. Before we can do that, we need to talk about the coding structure used by ggplot2. The analogy that I and many others use is to say that making a figure in ggplot2 is much like painting. What we’ve done in the above code is making our “canvas”. Now we are going to add sequential layers to that painting, increasing the complexity and detail over time. Each time we want to include a new layer we need to include a + at the end of the proceeding layer to tell R and ggplot2 that there are additional layers coming. There are other layers, beyond geoms, which can be included though we will focus on geoms for the time being. Let’s add (+) a new geom now: ggplot(aes(x = weight, y = shootarea), data = flower) + # Adding a geom to display data as point data geom_point() If what we wanted was a quick and dirty figure to get a grasp of the trend in the data we can stop here. We can see that shootarea looks like it’s increasing with weight in a linear fashion. So long as this answers the question we were asking from the data, we have a figure that is perfectly suited for personal use. Though for showing to other people we might want something a bit more developed. If we glance back to our “final figure” we can see that we have lines representing different nitrogen concentrations. We can include lines using a geom. If you have a quick look through the available geoms [here][geoms], you might think that geom_line() would be appropriate. Let’s try it. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Adding geom_line geom_line() Not quite what we were going for. The problem that we have is that geom_line() is actually just playing join-the-dots in the order they appear in the data (an alternative to geom_path()). The geom we actually want to use is called geom_smooth(). We can fix that very easily just by changing “line” to “smooth”. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Changing to geom_smooth geom_smooth() # `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Better, but still not what we wanted. The challenge here is that drawing a line is actually somewhat complicated. The way this line was drawn was using a method called “LOESS” (locally estimated scatterplot smoothing) which gives something very close to a moving average; useful in some cases, less so in others (ggplot2 will use LOESS as default when you have &lt; 1000 observations). Instead of a wiggly line, we want a nice simple straight line to be drawn using a method called “lm” (short for linear model - see Chapter 5 for more details). Try looking at the help file, using ?geom_smooth, to see what other options are available for the method = argument. While we’re at it, let’s get rid of the confidence interval ribbon around the line. I prefer to do this as I think it’s clearer to the audience that this isn’t a properly analysed line and to treat it as a visual aid only. We can do this at the same time as changing the method by setting the se = argument (short for standard error) to FALSE. Let’s update the code to use a linear model without confidence intervals. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Specifying the method as lm and se to false geom_smooth(method = &quot;lm&quot;, se = FALSE) That’s exactly what we wanted, though it’s still not matching the “final figure”. We need geom_smooth() to draw lines for each level of nitrogen concentration. Getting ggplot2 to do that is pretty straightforward. We can use the colour = argument within aes() (remember whatever we include in aes() will be something displayed in the figure) to tell ggplot2 to draw a different coloured line depending on nitrogen concentration. An aside: ggplot2 was written with both UK English and American English in mind, so both colour and color spellings work in ggplot2. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Including colour argument in aes() geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = FALSE) We’re getting closer, especially since ggplot2 has automatically created a legend for us. At this point it’s a good time to talk about where to include information - whether to include it within a geom or in ggplot(). When we include information such as data = and aes() in ggplot() we are setting those as the default, universal values which all subsequent geoms use. Whereas if we were to include that information within a geom, only that geom would use that specific information. In this case, we can easily move the information around and get exactly the same figure. ggplot() + # Moved aes() and data into geoms geom_point(aes(x = weight, y = shootarea), data = flower) + geom_smooth(aes(x = weight, y = shootarea, colour = nitrogen), data = flower, method = &quot;lm&quot;, se = FALSE) Doing so we get exactly the same figure. This ability to move information between the universal ggplot() or specific geoms is surprisingly powerful. It can allow different geoms to display different (albeit similar) information (see more on this later). For this worked example, we’ll move the same information back to the universal ggplot(),but we’ll also move colour = nitrogen into ggplot() so that we can have the points coloured according to nitrogen concentration as well. # Moved colour = nitrogen into the universal ggplot() ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) This figure is now what I would consider to be the typical ggplot2 figure (once you know to look for it, you’ll see it everywhere). We have specified some information, with only a few lines of code at that, yet we have something that looks quite attractive. While it’s not yet the “final figure” it is perfectly fit for purpose. You have now created you’re first “pure” ggplot. Let’s keep going as we’re aiming for something a bit more “sophisticated”. 4.2.2 Wrapping grids Having made our “pure” ggplot, the next big obstacle we’re going to tackle is the grid like layout of the “final figure” where the single figure has been split according to treatment and block, with new trends shown for each combination. ggplot2 includes options for determining the “facets” of a figure. We’ll start off by using facet_wrap() to show what this can do. For facet_wrap() to work we need to specify a formula for how the facets will be defined (see ?facet_wrap for more details and also for how to define facets without using a formula). You can read ~ treat as saying “according to treatment”. Let’s see how it works: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Splitting the single figure into multiple depending on treatment facet_wrap(~ treat) That’s pretty good, though we are missing the rows showing different blocks. Given that facet_wrap() can use a formula, maybe we could simply include block in the formula? Remember that block refers to the region in the greenhouse where the plants were grown. Let’s try it and see what happens. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Adding &quot;block&quot; to formula facet_wrap(~ treat + block) Play around: Try changing the formula to see what happens. Something like ~ treat + flowers or even ~ treat + block + flowers. The important thing to remember here is that facet_wrap() will create a new figure for each value in a variable. So when you wrap using a continuous variable like flowers, it makes a plot for every unique number of flowers counted. Be aware of what it is you are doing, but never be scared to experiment. Mistakes are easily fixed in R - it’s not like a point and click programme where you’d have to go back through all those clicks to get the same figure produced Made a mistake? Easy, change it back and rerun the code (see Chapter 8 for version control which takes this to the next level). This facet layout is almost exactly what we want. Almost. But not exactly. In this case we actually want to be using facet_grid(), an alternative to facet_wrap(), which should put us back on track to make the “final figure”. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Changing to facet_grid facet_grid(~ treat + block) That’s disappointing. It’s pretty much the same as what we had before and is no closer to the “final figure”. To fix this we need to do to rearrange our formula so that we say that it is block in relation to treatment (not in combination to). ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Rearranging formula, block in relation to treatment facet_grid(block ~ treat) 4.2.3 Plotting multiple ggplots And we’re there. Although the styling is not the same as the “final figure” this is showing the exact same fundamental information. We can plot them side-by-side to see how they compare. To do so we will use an additional package called patchwork. Go ahead and install and load patchwork (see Chapter 1.5 if you need a refresher for how to do this). An important note: For those who have used base R to produce their figure and are familiar with using par(mfrow = c(2,2)) (which allows plotting of four figures in two rows and two columns) be aware that this does not work for ggplot2 objects. Instead you will need to use either the patchwork package or alternative packages such as gridArrange or cowplot or covert the ggplot2 objects to grobs. We’ll need to go back to our previous code and do something clever. We can assign figures a name and then use that to call the figure whenever we run the name. For instance, I have assigned the “final figure” the name…. final_figure (I’m not a clever person). You may see this method used a lot in other textbooks, especially when adding addition layers (e.g. final_figure + geom_point()). I prefer not to do that here, instead favouring that the entire code is always visible. Regardless, let’s remind ourselves of the final figure. final_figure We’ll do the same with the figure we’ve created together: # Naming our figure object rbook_figure &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Now when the code is run, the figure won’t be presented. This will only happen when we run the name of the figure as code. Well use this at the same time as showing how patchwork works. An old headache when using ggplot2 was that it could be difficult to create a nested figure (different plots all part of the same figure). patchwork resolves this problem very elegantly and simply. We have two immediate and simple options with patchwork; figures on top of each other (operationalised with /) and figures side-by-side (operationalised with either + or |). Let’s try. # rbook_figure + final_figure Giving us a nested stacked figure. Play around: Try to create a side-by-side version of the above figure (hint: try the other operators). We can also assign nested patchwork figures a name and use this in turn to create labels for individuals figures. # nested_compare &lt;- rbook_figure + final_figure # nested_compare + # plot_annotation(tag_levels = &quot;A&quot;, tag_suffix = &quot;)&quot;) 4.2.4 Make it your own While we have a great figure already that shows the data we want it to show, it uses all of the default stylistic options. While the default options are arguably fine or even good, they may not be what we want ourselves. Maybe we’re going to use this figure in a presentation and we want to make sure someone in the very back of the room can easily read the figure. Maybe we want to use our own colour scheme. Maybe we want to change the grey background to a nice bright neon pink. In essence, maybe we want to decide things for ourselves. This next section will go through how to customise the appearance of our figure. Let’s start with the easier stuff, namely changing the size of the points using the size = argument. Before we do, have a think about where we’d include the argument? Should it be in ggplot() or geom_point()? Does size depend on a variable in our dataset and is therefore something we want displayed on the figure? Or is it merely changing the appearance of information? ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including size argument to change the size of the points geom_point(size = 2) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Straightforward, we changed the size from the default of size = 1 to a value that we decide for ourselves. What happens if you included size in ggplot() or within the aes() of geom_point()? If we wanted to change the shape of the points to reflect nitrogen concentrations, how do you think we’d do that? We’d use the shape = argument, but this time we need to include an aes() within geom_point() because we want to include specific information to be displayed on the figure. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including shape argument to change the shape of the points geom_point(aes(shape = nitrogen), size = 2) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Try including shape = nitrogen without also including aes() and see what happens. We’re getting closer and closer to the “final figure”. Another thing we may want to be able to do is change the transparency of the points. While it’s not actually that crucial here (arguably it might not be a good idea), changing the transparency of points is really valuable when you have lots of data and big clusters of points can be hidden. Doing this is, again, surprisingly easy, accomplished using the alpha = argument. Again, ask yourself where you think the alpha = argument should be included. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including alpha argument to change the transparency of the points geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) We can also include defined labels for the x and y axis. There are a couple of ways to do this, but my preferred way is the same as used in base R figures; using xlab() and ylab(). As we are going to be creating new layers and adding them onto the figure, we’ll need to convey this to ggplot2 using +. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + # Adding layers for x and y labels xlab(&quot;Weight of flower (g)&quot;) + ylab(&quot;Area of shoot (cm^2)&quot;) Great. Just as we wanted, though getting the “(cm^2)” to show the square as a superscript would be ideal. Here, we’re going to accomplish that using a function which is part of base R called bquote() which allows for special characters to be shown. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + # Using bquote to get mathematically correct formatting ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) Let’s now work on the legend title while also including a caption to warn people looking at the figure to treat the trend lines with caution. We’ll use a new layer called labs(), short for labels, which we could have also used for specifying the x and y labels (we didn’t only for demonstration purposes, but give it a shot). labs() is a fairly straightforward function. Have a look at the help file (using ?labs) to see which arguments are available. We’ll be using caption = for the caption, but notice that there isn’t an argument for legend =? That’s because the legend is in fact multiple pieces of information; one being colour and one being shape. So instead of legend = we’ll use colour = and shape =. Here’s how we do it: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + # Adding labels for shape, colour and a caption labs(shape = &quot;Nitrogen Concentration&quot;, colour = &quot;Nitrogen Concentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) Play around: Try removing colour = or shape = from labs() to see what happens. The resulting legends are why we need to specify both colour and shape (and call it the same thing). Now is a good time to introduce “backslash n”. This is a base R feature which can be thought of as pressing Return in a word processor. It tells R that a string should be continued on a new line. We can use that with “Nitrogen Concentration” so that the legend title becomes more compact. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + # Including \\n to split legend title over two lines labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) We can now move onto some more wholesale-stylistic choices using the much loved themes of ggplot2. 4.2.5 Setting the theme ggplot2 contains so called themes. Themes control the base style of a ggplot. Let’s play around with themes using some skills we’ve already learnt; assigning plots to objects and plotting multiple ggplots in a single figure to explore some theme options. We assign themes by creating a new layer with theme_X(). classic &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Classic theme theme_classic() bw &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Black and white theme theme_bw() minimal &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Minimal theme theme_minimal() light &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Light theme theme_light() # (classic | bw) / # (minimal | light) In terms of finding a theme that most closely matches our “final figure”, it’s probably going to be theme_classic(). There are additional themes available to you, and even more available online. ggthemes is a package you can download to get even more theme options. The BBC even have their own ggplot2 theme called “BBplot” (though I personally don’t like it too much for scientific figures). Indeed, you can even make your own theme which is what we’ll work on next. To begin with, we’ll have a look to see how theme_classic() was coded. We can do that easily enough by just writing the function name without the paranethesis (brackets). theme_classic # function (base_size = 11, base_family = &quot;&quot;, base_line_size = base_size/22, # base_rect_size = base_size/22) # { # theme_bw(base_size = base_size, base_family = base_family, # base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% # theme(panel.border = element_blank(), panel.grid.major = element_blank(), # panel.grid.minor = element_blank(), axis.line = element_line(colour = &quot;black&quot;, # size = rel(1)), legend.key = element_blank(), # strip.background = element_rect(fill = &quot;white&quot;, colour = &quot;black&quot;, # size = rel(2)), complete = TRUE) # } # &lt;bytecode: 0x7fc9944ccb00&gt; # &lt;environment: namespace:ggplot2&gt; Let’s use this code as the basis for our own theme and modify it according to our needs. We’ll call the theme, theme_rbook. Not all of the options will immediately make sense, but don’t worry about this too much for now. Just know that the settings we’re putting in place are: Font size for axis titles = 20 Font size for x axis text = 10 Font size for y axis text = 10 Font for caption = 10 and italics Background colour = white Background border = black Axis lines = black Strip colour (for facets) = black Strip text colour (for facets) = white Legend box colours = blank This is by no means an exhaustive list of features you can specify in your own theme, but this will get you started. Of course, there is no need to use a personalised theme as the pre-built options are perfectly suitable. theme_rbook &lt;- function(base_size = 20, base_family = &quot;&quot;, base_line_size = base_size/22, base_rect_size = base_size/22) { theme( axis.title = element_text(size = 20), axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), plot.caption = element_text(size = 10, face = &quot;italic&quot;), panel.background = element_rect(fill=&quot;white&quot;), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size=0.5), axis.line = element_line(size = 1, colour = &quot;black&quot;), strip.background =element_rect(fill = &quot;black&quot;), strip.text = element_text(colour = &quot;white&quot;), legend.key=element_blank() ) } theme_rbook() is now available for us to use just like any other theme. Let’s try remaking our figure using our new theme. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Updated theme to our theme_rbook theme_rbook() 4.2.6 Prettification We’ve pretty much got to our “final figure”. We just have a few final adjustments to make, and we’ll do so in order of difficulty. Let’s remind ourselves of what that “final figure” looked like. Remember, since I have previously stored the figure as final_figure I can just type that into the console and pull up the figure. final_figure + labs(title = &quot;Reminder of the final figure&quot;) Let’s begin the final push by including that dashed horizontal line at about 80 on our y axis. This represents the overall mean area of a shoot, regardless of weight of flower, nitrogen concentration, treatment, or block. To draw a horizontal line we use a geom called geom_hline(), and the most important thing we need to specify is the y intercept value (in this case being our mean area of a shoot). We can also change the type of line using the argument linetype = and also the colour (as we did before). Let’s see how it works. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Added a horizontal line using geom_hline geom_hline(aes(yintercept = mean(shootarea)), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() Notice how we included the function mean(shootarea) within the geom_hline() function? We could also do that externally to the ggplot2 code and get the same result. mean(flower$shootarea) # [1] 79.8 ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Manually entering mean value geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() Exactly the same figure but produced in a slightly different way (the point being that there are always multiple ways to get code to do what you want), which brings us ever closer to that “final figure”. Let’s tackle that “overall” nitrogen effect. This overall line is effectively the figure we produced much earlier when we learnt how to get a line drawn using a linear model. But we are already using geom_smooth(), surely we can’t use it again? This may shock and/or surprise you so please ensure you are seated. You can use geom_smooth() again. In fact you can use it as many times as you want. You can use any layer as many times as you want! Isn’t the world full of wonderful miracles? … Anyway, here’s the damn code… ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Adding a ***SECOND*** geom_smooth :O geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() That’s great! But you should be asking yourself why that worked. Why when we specified the first geom_smooth() did it draw 3 lines, whereas the second time we used geom_smooth() it just drew a single line? The secret lies in a “conflict” (it isn’t actually a conflict but I’ll call it that here) between the colour specified in the universal ggplot() and the colour specified in the second geom_smooth(). Notice how in the second we’ve specifically told ggplot2 that the colour will be black, while prior to this it drew lines based on the number of groups (or colours) in nitrogen? In “overriding” the universal ggplot() with a geom specific argument we’re able to get ggplot2 to plot what we want. The only things left now are to change the colour and the shape of the points to something of our choosing and include the “overall” trend line in the legend. We’ll begin with the former; changing colour and shape to something we specifically want. When I first started using ggplot2 this was actually the thing which caused me most difficulty. I think the reason is, that to manually change the colours actually requires an additional layer, where I assumed this would be done in either the universal ggplot() or in a geom. Instead of doing this within the specific geom, we’ll use scale_colour_manual() as well as scale_shape_manual(). Doing it this way will allow us to do two things at once; change the shape and colour to our choosing, and assign labels for these (much like what we did with xlab() and ylab()). Doing so is not too complex but will require nesting a function within another function, using c() (see chapter XXX for a reminder on the concatenate function). Choosing colours can be fiddly. I’ve found using a colour wheel helps with this step. Either Google to find a decent interactive colour wheel or use this website. Follow the steps to choose three colours of your choice. The website should give you a string, something like: #5C1AAE which are the “code” representations of those colours (technically called rgb specifications, which both R and ggplot2 understand). Alternatively, there are colour names which R and ggplot2 will also understand (e.g. “firebrick4”). Having chosen our colours using whichever means, let’s see how we can do it: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + # Setting colour and associated labels scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Setting shape and associated labels scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() To make sense of that code (or any code for that matter) try running it piece by piece. For instance in the above code, if we run c(&quot;violetred3&quot;, &quot;limegreen&quot;, &quot;purple4&quot;) we’ll get a list of those strings. That list is then passed on to scale_colour_manual() as the colours we wish to use. Since we only have three nitrogen concentrations, it will use these three colours. Try including an additional colour in the list and see what happens (if you place the new colour at the end of the list, nothing will happen since it will use the first three colours of the list - try adding it to the start of the list). The same is true for scale_shape_manual(). But if you’re paying close attention you’ll notice that there’s a mistake with the figure now. What should be labelled “Low” is actually labelled “Medium” (the green points and line are our low nitrogen concentration, but ggplot2 is saying that it is purple). ggplot2 hasn’t made a mistake here. We have. Remember that code is purely logical (or a golem using R McElreath’s terminology). It will do explicitly what it is told to do, and in this case we have told it to call the labels High, Medium and Low. We could have just as easily told ggplot2 to call them Pretoria, Tokyo, and Copenhagen. The lesson here is to always be critical of what your outputs are. Never assume that you are omnipotent and will never make mistakes. Double check everything you do. So how do we fix this? We need to do a little data manipulation to rearrange our factors so that the order goes High, Medium, Low. Let’s do that: flower$nitrogen &lt;- factor(flower$nitrogen, levels = c(&quot;high&quot;, &quot;medium&quot;, &quot;low&quot;)) With that done, we can re-do our above code to get a correct figure and assign it the name “rbook_figure”. rbook_figure &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() rbook_figure And we’ve done it! Our final figure matches the “final figure” exactly. We can then save the final figure to our computer so that we can include it in a poster etc. The code for this is straightforward, but does require an understanding of file paths. Be sure to check Chapter X for an explanation of this if you’re unsure. This is the point when assigned the code to the object named “rbook_figure” comes in handy. Doing so allows us to specify which figure it is we want to save within ggsave(). If we hadn’t specified which plot to save, ggsave() would instead save the most current figure produced. Other important arguments to take note of are: device = where we tell ggplot2 in what form we want the figure saved as (in this case saved as a .pdf) though ggplot2 is smart enough to guess this based on the extension of ourfile name, so it is often redundant; units = which specifies the units used in width = and height =; wight = and height = which specify the width and height of figure (in this case in mm as per units =); dpi = which controls the resolution of the saved figure; and limitsize = which prevents accidentally saving a figure 1 km x 1 km. ggsave(filename = &quot;areashoot_weight_facet.pdf&quot;, plot = rbook_figure, device = &quot;pdf&quot;, path = &quot;C:\\\\Users\\\\deonr\\\\Desktop&quot;, width = 250, height = 150, units = &quot;mm&quot;, dpi = 500, limitsize = TRUE) This concludes the worked example to reproduce our final figure. While absolutely not an exhaustive list of what you can do with ggplot2, this will hopefully help when you’re making your own from scratch or, perhaps likely when starting, copying ggplots made by other people (in which case hopefully this will help you understand what they’ve done). Two sections follow this one. The first is simply a collection of tips and tricks that couldn’t quite make their way into this worked example, and the second section is a bestiary of different ggplots. I would recommend only glancing through each section, coming back to them as and when you need to know how to do that particular thing. I want to finish this chapter by saying that I hope you enjoyed it, and more importantly, that you increased your confidence in making figures. If I can have two final parting words, the first would be to reiterate not to fall into the trap of thinking your figures are superior to those who don’t use ggplot2. As I said in the beginning, exactly equivalent figures are possible in both base R and ggplot2. The only difference is how you get to those figures. The last advice I will give is to warn against overcomplicating your figures, something easily done in general and perhaps particularly so in ggplot2. With regards to the final figure we produced here, I have gone back and forth as to whether I think I have been guilty of that here. The figure does contain a lot of information, drawing on information from five different variables, with one of those being presented in three different ways. I would be reluctant, for example, to include this in a presentation as it would likely be too much for an audience to fully appreciate in the roughly 30 seconds to 1 minute that they’ll see it. In the end I decided it was worth the risk as it served as a nice demonstration. Fortunately, or unfortunately depending on your view, there are no true hard and fast rules when it comes to making figures. Much of it will be at your descretion, so please ensure you give it thought. Sincerly, a viewer of one of your future conference posters, a future audience memeber at one of your talks, and a future reader of one of your papers. "],
["tips-and-tricks.html", "4.3 Tips and tricks", " 4.3 Tips and tricks For this section I’ll use the version of the final figure without including the facet_grid(). I do so only to allow the changes to be more apparent. With this altered plot, I’ll run through some tips and tricks that I wish I had learnt when I started using ggplot2. 4.3.1 Axis limits and zooms Fairly often, you may want to limit the range of your axes. Maybe you want to focus a particular part of the data to really tease apart any patterns occuring there. Whatever the reason, it’s a useful skill to know, and with most things code, there are a couple of ways to do this. I’ll show two here; xlim() and ylim() and coord_cartesian(). Using both of these we’ll set the x axis to only show data between 10 and 15 g and the yaxis to only show the area of the shoot between 50 and 150. We’ll start with limiting the axes: ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(colour = &quot;black&quot;, method = &quot;lm&quot;, se = F, linetype = 2, alpha = 0.6) + geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = F, size = 1.2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() + # New x and y limits xlim(c(10, 15)) + ylim(c(50, 150)) # Warning: Removed 68 rows containing non-finite values (stat_smooth). # Warning: Removed 68 rows containing non-finite values (stat_smooth). # Warning: Removed 68 rows containing missing values (geom_point). # Warning: Removed 6 rows containing missing values (geom_smooth). Notice the warning messages we get, telling us that n rows contain either missing or non-finite values? That’s because we’ve essentially chopped out a huge part of our data using this method (everything outside of the ranges that we specified). As a result of doing this our lines have no completely changed direction. Notice that for low nitrogen concentration, the line is being drawn using only two points? This may, or may not be a problem depending on the aim we have, but we can use an alternative method; coord_cartesian(). coord_cartesian() works in much the same way, but instead of chopping out data, it instead zooms in. Doing so means that the entire dataset is maintained (and any trends are maintained). ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(colour = &quot;black&quot;, method = &quot;lm&quot;, se = F, linetype = 2, alpha = 0.6) + geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = F, size = 1.2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() + # Zooming in rather than chopping out coord_cartesian(xlim = c(10, 15), ylim = c(50, 150)) Notice now that the trends are maintained (as the lines are being informed by data which are off-screen). I would generally advise using coord_cartesian() as it protects you against possible misinterpretations. 4.3.2 Layering layers Remember that ggplot2 works like painting. Let’s imagine we were one of the great renaissance painters. We’ve just finished the focal point of our painting, the half naked Duke of Toulouse looking moody or something. Now that we’ve finished painting the honourable Duke, we proceed to paint the background, a beautiful landscape showing the Pyrenees mountains in the distance. Unfortunately, in doing so we’ve painted over the Duke, because the order of our layers were wrong. We get our heads chopped off, but learn a valuable lesson in the process: the order of layers matter. The exact same is true in ggplot2 (minus the chopping off of heads, though your situation may vary). The layers are read and “painted” in order of their appearance in the code. If geom_point() comes before geom_col(), then your points may well end up being hidden. To fix this is especially easy, we simply need to move the layers up or down in the code. A useful tip for those using Rstudio, is that you can do move lines of code especially easily. Simply click on a line of code, hold down Alt and then press either the up or down arrows, and the entire line will move up or down as well. For multiple lines of code, simply highlight all those lines you want to move and press Alt + Up/Down. We’ll move both the points and the Overall black dashed line down in the code so that they are superimposed over the nitrogen lines: ggplot(aes(x = weight, y = shootarea), data = flower) + geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = F, size = 1.2) + # Move one line down geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) + # Moved one line down geom_smooth(colour = &quot;black&quot;, method = &quot;lm&quot;, se = F, linetype = 2, alpha = 0.6) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() It’s not the clearest example, but give it a shot with your own data. 4.3.3 Continuous colours Instead of categorical colours, such as we’ve used for nitrogen concentration, what if instead we wanted a gradient? To illustrate this, we’ll remove the trend lines to highlight the changes we make. We’ll also be using the flowers variable (i.e. number of flowers) to specify the colour that points should be coloured. We have three options; the default colour scheme, scale_colour_gradient(), and scale_colour_gradient2(). Remember that we’ll also need to change our label for the legend. We’ll start with the default option. Here we only need to change nitrogen (which is a factor) to flowers (which is continuous) in the colour = argument within aes(): ggplot(aes(x = weight, y = shootarea), data = flower) + # Deleted geom_smooths for illustrative purposes only (and also alpha argument from geom_point geom_point(aes(colour = flowers, shape = nitrogen), size = 2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + # Changed colour argument label labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Number of\\nFlowers&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() And as easily as that we have a colour gradient to show number of flowers. Dark blue shows low flower numbers and light blue shows higher flower numbers. While the code has worked, I have a hard time distinguishing between the different shades of blue. It would help ourselves and our audience, if we changed the colours to something more notceably different, using scale_colour_gradient(). This works much as scale_colour_manual() except that this time we specify the low = and high = values using arguments. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(aes(colour = flowers, shape = nitrogen), size = 2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + # Updated legend name for colour labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Number of\\nFlowers&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Adding scale_colour_gradient scale_colour_gradient(low = &quot;#9F00FF&quot;, high = &quot;#FF9F00&quot;) + theme_rbook() Arguably better, though I still struggle to spot the difference when there are between 5 and 12 flowers. Maybe having an additional colour would help those mid values stand out a bit more. The way we can do that here is to set a midpoint where the colours shift from green to blue to pink. Doing so might help us even more to see the variation. This is exactly what scale_colour_gradient2() allows. scale_colour_gradient2() works in much the same way as scale_colour_gradient() except that we have two additional arguments to worry about; midpoint = where we specify a value for the midpoint, and mid = where we state the colour the midpoint should take. We’ll set the midpoint using mean() but importantly, we’ll use extraction brackets again to ensure that row 70 is not included in this step. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(aes(colour = flowers, shape = nitrogen), size = 2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Number of\\nFlowers&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Adding scale_colour_gradient2 scale_colour_gradient2(midpoint = mean(flower$flowers), low = &quot;#9F00FF&quot;, mid = &quot;#00FF9F&quot;, high = &quot;#FF9F00&quot;) + theme_rbook() Maybe a bit better. Hard to say. Perhaps if we add more colours, that will help things a bit. We now move onto using scale_colour_gradientn(), which diverges slightly. Instead of specifying colours for low, mid, and/or high, here we’ll be specifying them using proportions within the values = argument. A common mistake with values =, within scale_colour_gradient(), is to assume (justifiably in my opinion) that we’d specify the actual numbers of flowers as our values. This is wrong. Try doing so and you’ll likely see a grey colour bar and grey points. Instead values = represent the proportional ranges where we want the colour to occupy. In the code below, we use 0, 0.25, 0.5, 0.75 and 1 as our proportions, corresponding to 4 colours (note that we have one fewer colours than proportions given the colours occupy a range and not a value). ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(aes(colour = flowers, shape = nitrogen), size = 2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Number of\\nFlowers&quot;, caption = &quot;Lines are only to suggest trends&quot;) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Adding scale_colour_gradientn scale_colour_gradientn(colours = c(&quot;#1252ED&quot;, &quot;#12ED3F&quot;, &quot;#EDAD12&quot;, &quot;#ED12C0&quot;), values = c(0, 0.25, 0.5, 0.75, 1)) + theme_rbook() Not my favourite figure, but it’s doing what we wanted it to do, so we shouldn’t really complain. 4.3.4 Size of points Previously, we altered to size of points to be a constant number (e.g. size = 2). What if instead we wanted size to change according to a variable in our dataset? We can do this very easily by including a continuous variable with the size = argument. ggplot(aes(x = weight, y = shootarea), data = flower) + # Moving size into aes and changing to a continuous variable geom_point(aes(colour = nitrogen, shape = nitrogen, size = height), alpha = 0.6) + geom_smooth(colour = &quot;black&quot;, method = &quot;lm&quot;, se = F, linetype = 2, alpha = 0.6) + geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = F, size = 1.2) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + # Including size label labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;, size = &quot;Plant\\nHeight (cm)&quot;) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() Now the sizes reflect the height of the plants, with bigger points representing taller plants and vice-versa. 4.3.5 Moving the legend To move the position of the legend requires tweaking the theme, just as we did before with theme_rbook(). But for legends we might not want this set as a hard rule whenever we use the theme (i.e. coding this into theme_rbook()). Instead we can change it on the fly depending on the individual figure. To do so, we can use a theme() layer and the argument legend.position =, followed swiftly by a layer specifying that we still want to use theme_rbook(). ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Moving the legend theme(legend.position = &quot;bottom&quot;) + theme_rbook() Play around: Try the above code but don’t include theme_rbook() and see what happens? What about if you try theme_rbook(legend.position = &quot;bottom&quot;)? 4.3.6 Hiding the legend Suppose we don’t want a legend at all. How would we go about hiding it? ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Hiding the legend theme(legend.position = &quot;none&quot;) + theme_rbook() 4.3.7 Hiding part of the legend What if we really don’t want points included in the legend? Instead of stating this using theme(), we’ll include it within geom_point() using show.legend = FALSE. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including show.legend = FALSE to prevent inclusion in legend geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6, show.legend = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() 4.3.8 Writing on a figure What if we were so utterly proud of our figure that we wanted to sign it (just like a painter signs their works of art)? We can do this using geom_text(). If we want to change the font, we need to check which ones are available for us to use. We can check this by runnings windowsFonts(). We’ll use Times New Roman in this example, which is referred to as serif. Not happy with your font options? Check our the extrafont package which expands your fontage. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Including layer to display text geom_text(x = 22, y = 5, label = &quot;A. Artist&quot;, colour = &quot;grey&quot;, family = &quot;serif&quot;) + theme_rbook() In reality there are more appropriate uses for geom_text() but whatever the reason, the mechanics remain the same. We specify what the x and y position are (on the scales of the axes), what we want written (using label =), the font (using family =). Similarly, we want to include a tag for the figure, for instance we may want to refer to this figure as A if we had nested figures. We can do this using an additional argument in labs(). Let’s see how that works: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + # Including tag argument labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;, tag = &quot;A&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() Doing so we get an “A” at the top left of the figure. If we weren’t happy with the position of the “A”, we can always use geom_text() instead and position it ourselves. 4.3.9 Ticks and tick labels What are we to do if we want more or fewer ticks on an axis? We can do this using the appropriate layers; scale_y_discrete() and scale_x_discrete() for discrete data (e.g. factors); and scale_y_continuous() and scale_x_continuous() for continuous data. Within these layers, the argument we want to use is called breaks =, though we need to use this in combination with seq() (see Chapter XXX for a reminder on how seq() works). We’ll alter the x axis ticks in this example, with a tick label every 2.5 units. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Adjusting breaks on x axis scale_x_continuous(breaks = seq(from = 5, to = 25, by = 2.5)) + theme_rbook() Axis tick labels sometimes need to be rotated. If you’ve ever worked with data from multiple species (with those lovely long latin names) for example, you’ll know that it can be a nightmare making figures. The names can end up overlapping to such an extent that you axis tick labels merge into a giant black blob of unreadable abstractionism. In such cases it’s best to rotate the text to make it readable. Doing so isn’t too much of a pain and we’ll be using theme() to set angle to 45 degress in addition to a little vertical adjustment so that the text doesn’t get too close or run too far away from the axis. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;#5C1AAE&quot;, &quot;#AE5C1A&quot;, &quot;#1AAE5C&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Changing the angle of the axis text theme(axis.text.x=element_text(angle = 45, vjust = 0.5)) + theme_rbook() Phew. Now we can really read those numbers. Granted rotating the axis text here isn’t needed, but keep this trick in mind if you have lots of levels in a factor which leads to illegible blobs. To round off this chapter, I will take you on a whistle-stop tour of some of the common types of plots you can make in the aptly named ggplot catalogue section. "],
["a-ggplot-bestiary.html", "4.4 A ggplot bestiary", " 4.4 A ggplot bestiary What follows is a quick run through of example ggplots. These will predominantly be done by changing the geoms used, but there will be additional slight tweaks which I’ll highlight. 4.4.1 Density plot Below is a density plot which is much like a histogram. The x axis shows observations of given numbers of flowers, while the y axis is the density of observations (roughly equivalent to number of rows with that many flowers). Each density is coloured according to nitrogen concentration, though note that we’re using fill = instead of colour =. Try using colour instead to see what happens. Notice that we haven’t used data = flowers here and instead just used flowers? When an object is not assigned with an argument, ggplot2 will assume that it is the dataset. We’re using that here, but I actually prefer to explicitly state what arguments are being fulfilled in my own work. ggplot(flower) + geom_density(aes(x = flowers, fill = nitrogen), alpha = 0.5) + labs(y = &quot;Density&quot;, x = &quot;Number of Flowers&quot;, fill = &quot;Nitrogen\\nConcentration&quot;) + scale_fill_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;#DB24BC&quot;, &quot;#BCDB24&quot;, &quot;#24BCDB&quot;)) + theme_rbook() 4.4.2 Histogram Next is a histogram (a much more traditional version of a density plot). There are a couple of things to take note of here. The first is that flower$block is numeric and not a factor. We can correct that here fairly easily using the factor() function to convert it from numeric to factor (though ideally we’d have done this before - see Chapter 3). The other thing to take note of is that I’ve specified bins = 20. The number of bins control how many times the y-axis is broken up to show the data. Try increasing and decreasing to see the effect. ggplot(flower) + geom_histogram(aes(x = flowers, fill = factor(block)), colour = &quot;black&quot;, bins = 20) + labs(y = &quot;Count&quot;, x = &quot;Number of Flowers&quot;, fill = &quot;Greenhouse\\nBlock&quot;) + scale_fill_manual(labels = c(&quot;1&quot;, &quot;2&quot;), values = c(&quot;#8CD926&quot;, &quot;#7326D9&quot;)) + # HULK SMASH! theme_rbook() 4.4.3 Frequency polygons ggplot(flower) + geom_freqpoly(aes(x = flowers, colour = factor(block)), size = 1, bins = 20) + labs(y = &quot;Count&quot;, x = &quot;Number of Flowers&quot;, colour = &quot;Greenhouse\\nBlock&quot;) + scale_colour_manual(labels = c(&quot;1&quot;, &quot;2&quot;), values = c(&quot;#8CD926&quot;, &quot;#7326D9&quot;)) + # HULK SMASH! theme_rbook() 4.4.4 Boxplot Boxplots are a classic way to show to spread of data, and they’re easy to make in ggplot2. The dark line in the middle of the box shows the median, the boxes show the 25th and 75th percentiles (which is different from the base R boxplot()), and the whiskers show 1.5 times the inter-quartile range (i.e. the distance between between the first and third quartiles). We can also make the boxes notched using the argument notch = TRUE. Notches extend (1.58 times the inter-quartile range) / square root of the number of observations. If notches do no overlap, it suggest (but only suggests) there may be a significant difference between groups. ggplot(flower) + geom_boxplot(aes(y = flowers, x = nitrogen), notch = TRUE) + labs(y = &quot;Number of Flowers&quot;, x = &quot;Nitrogen Concentration&quot;) + theme_rbook() 4.4.5 Violin plots Violin plots are an increasingly popular alternative to boxplots. They display much of the same information, as well as showing a version of the density plot above (imagine each violin plot, cut in half vertically, showing the overall distribution of the data). In the plot below the figure is slightly more complex than those above and so deserves some explanation. Within geom_violin() we’ve included draw_quantiles = where we’ve specified we want quantile lines drawn at the 25, 50 and 75 quantiles (using the c() function). In combination with geom_violin() we’ve also included geom_jitter(). geom_jitter() is similar to geom_point() but induces random spread of the points, often helpful when points would otherwise be clustered. Within geom_jitter() we’ve also set height = 0, and width = 0.1 which specifies how much to jitter the points in a given dimension (here essentially telling ggplot2 not to jitter by height, and only to jitter width by a small amount). Finally, I’m also using this plot to show scale_y_log10. Hopefully this is largely self-explanatory (it converts the y-axis to the log10 scale). There are additional scaling options for axis (for instance scale_y_sqrt()). Please note that using a log scaled axis in this case is actually doing harm, in terms of understanding the data, we’d be much better off not doing so in this particular case. ggplot(flower) + geom_violin(aes(y = flowers, x = nitrogen, fill = nitrogen), draw_quantiles = c(0.25, 0.5, 0.75)) + geom_jitter(aes(y = flowers, x = nitrogen), colour = &quot;black&quot;, height = 0, width = 0.1, alpha = 0.5) + scale_fill_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;#5f7f5c&quot;, &quot;#749770&quot;, &quot;#9eb69b&quot;)) + labs(y = &quot;Number of Flowers&quot;, x = &quot;Nitrogen Concentration&quot;) + scale_y_log10() + theme_rbook() 4.4.6 Barchart Below is an example of barcharts. It is included here for completeness, but be aware that they are viewed with contention (see here for a discussion of why LINK). Briefly, there are almost always better alternatives to use that better demonstrate the trends. ggplot(flower) + geom_bar(aes(x = factor(block), fill = nitrogen)) + scale_fill_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;#2613EC&quot;, &quot;#9313EC&quot;, &quot;#EC13D9&quot;)) + labs(y = &quot;Count&quot;, x = &quot;Block&quot;) + theme_rbook() The barchart shows the numbers of observations in each block, with each bar split according to the number of observations in each nitrogen concentration. In this case they are equal because the dataset (and experimental design) was balanced. 4.4.7 Quantile lines While we can draw a straight line, perhaps we would also like to include the descriptive nature of a boxplot, except using continuous data. We can use quantile lines in such cases. Note that for quantiles to be calculated ggplot2 requires the installation of the package quantreg. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point(size = 0.5, alpha = 0.6) + geom_quantile(colour = &quot;darkgrey&quot;, size = 1) + labs(y = &quot;Shoot Area&quot;, x = &quot;Weight&quot;) + theme_rbook() # Smoothing formula not specified. Using: y ~ x 4.4.8 Heatmap When using spatial data, heatmaps can be a great tool to visual spatial patterns. ggplot2 can easily handle such data using geom_bin2d(). Even when not using spatial data, the figure can allow us to see if our data is more (or less) clustered. ggplot(aes(x = leafarea, y = shootarea), data = flower) + geom_bin2d() + labs(y = &quot;Shoot Area&quot;, x = &quot;Leaf Area&quot;) + coord_cartesian(xlim = c(5,25)) + theme_rbook() In this example, lighter blue squares show combinations of leaf area and shoot area where we have more data, and dark blue shows the converse. 4.4.9 Hex map A similar version to geom_density2d() is geom_hex(). The only difference between the two is that the sqaures are replaced with hexagons. Note that geom_hex() requires an additional package called hexbin. library(hexbin) ggplot(aes(x = leafarea, y = shootarea), data = flower) + geom_hex() + labs(y = &quot;Shoot Area&quot;, x = &quot;Leaf Area&quot;) + coord_cartesian(xlim = c(5,25)) + theme_rbook() 4.4.10 Contour map Similar to a heatmap we can make a contour map using geom_density_2d(). The way to read this figure is much the same way as you’d read a topographical map showing “mountains” or peaks. The central polygon represents the space (amongst shoot and leaf area) where there are most observations. As you “step” down this mountain to the next line, we step down in the number of counts. Think of this as showing where points are most clustered, as in geom_bin2d(). ggplot(aes(x = leafarea, y = shootarea), data = flower) + geom_density2d() + labs(y = &quot;Shoot Area&quot;, x = &quot;Leaf Area&quot;) + coord_cartesian(xlim = c(5,25)) + theme_rbook() We can then expand on this using stat(). In the background of ggplot2 values are calculated which are then passed to some geoms. stat() acts like a flag to ggplot2 that you want to use one of these calculated values. For instance, we can use the calculated “level” and use this to fill in our figure. To do so, we’ll swap out geom_density_2d() for stat_density_2d() which will allow us to paint the contour map. ggplot(aes(x = leafarea, y = shootarea), data = flower) + stat_density_2d(aes(fill = stat(level)), geom = &quot;polygon&quot;) + labs(y = &quot;Shoot Area&quot;, x = &quot;Leaf Area&quot;) + coord_cartesian(xlim = c(5,25)) + theme_rbook() In this case it doesn’t look too pretty given that we don’t have a wide spread of data (as we would hope for with spatial data) leading to partly formed polygons. 4.4.11 Cleveland dotplot The cleveland dotplot is a figure well suited to detect outliers in the data. The y axis is simply the order in which the data appears in the dataset. The x axis is our variable of interest. Points far to the left or far to the right are indicative of outliers. ggplot2 does not have a geom specifically designed for a cleveland dotplot, though we can bend ggplot2 to our will. We do this by first using the function rownames(). This function returns the row name of each row. In most dataframes, the row names are simply numbers. Once we have this information, we can convert this to numbers using as.numeric(). Once this is done, we essentially have a vector of numbers from 1 to 96. Keep in mind that such techniques can be used for any sort of figure we want to make. ggplot(flower) + geom_point(aes(x = leafarea, y = as.numeric(rownames(flower)))) + labs(y = &quot;Order in Dataset&quot;, x = bquote(&quot;Area of leaf&quot;~(cm^2))) + theme_rbook() 4.4.12 Pairs plot For this next figure we will need an additional package, called GGally. Within GGally is a function called ggpairs() which is equivalent to pairs() (part of base R). Both function produce comparative plots of all variables of interest. Running diagonally down from left to right, are plots showing distributions; either as stacked barcharts or as density plots, in this case coloured according to nitrogen concentration. The bottom plots show the plotted relationships, with variables on the top as the x axis, and the variables on the right plotted as the y axis. For example, the very bottom left plots shows the relationship between number of flowers on the y axis and treatment on the x axis, coloured according to nitrogen concentration. Conversely, the upper plots show either the correlation between variables, when both variables are continuous and the correlation can be calculated, boxplots when the plot is of a factor variable and a continuous variable, or as a stacked barchart when both variables are factors. Such figures are a fantastic way to quickly show relationships in the dataset. They can of course be used to plot only part of the dataset, for instance using flowers[ , 1:5] to plot the first five columns of the dataset. library(GGally) # Registered S3 method overwritten by &#39;GGally&#39;: # method from # +.gg ggplot2 flower$block &lt;- factor(flower$block) ggpairs(flower, ggplot2::aes(colour = nitrogen)) + theme_rbook() # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. "],
["stats-r.html", "Chapter 5 Simple Statistics in R", " Chapter 5 Simple Statistics in R content to follow "],
["prog-r.html", "Chapter 6 Programming in R", " Chapter 6 Programming in R content to follow Ana add to this "],
["rmarkdown-r.html", "Chapter 7 Reproducible reports with R markdown", " Chapter 7 Reproducible reports with R markdown This chapter will introduce you to creating reproducible reports using R markdown to encourage best (or better) practice to facilitate open science. It will first describe what R markdown is and why you might want to consider using it, describe how to create an R markdown document using RStudio and then how to convert this document to a html or pdf formatted report. During this Chapter you will learn about the different components of an R markdown document, how to format text, graphics and tables within the document and finally how to avoid some of the common difficulties using R markdown. I estimate that this Chapter should take you roughly 1.5 to 2.5 hours to complete in one sitting, but feel free to dip in and out over a longer period if that suits you better. "],
["what-is-r-markdown.html", "7.1 What is R markdown?", " 7.1 What is R markdown? R markdown is a simple and easy to use plain text language used to combine your R code, results from your data analysis (including plots and tables) and written commentary into a single nicely formatted and reproducible document (like a report, publication, thesis chapter or a web page like this one). Technically, R markdown is a variant of another language (yet another language!) called Markdown and both are a type of ‘markup’ language. A markup language simply provides a way of creating an easy to read plain text file which can incorporate formatted text, images, headers and links to other documents. Don’t worry about the details for the moment, although if you’re interested you can find more information about markup languages here. Actually, if it makes you feel any better all of you will have been exposed to a markup language before, as most of the internet content you digest every day is underpinned by a markup language called HTML (Hypertext Markup Language). Anyway, the main point is that R markdown is very easy to learn (much, much easier than HTML) and when used with RStudio it’s ridiculously easy to integrate into your workflow to produce feature rich content (so why wouldn’t you?!). "],
["why-use-r-markdown.html", "7.2 Why use R markdown?", " 7.2 Why use R markdown? During the previous Chapters we talked a lot about conducting your research in a robust and reproducible manner to facilitate open science. In a nutshell, open science is about doing all we can to make our data, methods, results and inferences transparent and available to everyone. Some of the main tenets of open science are described here and include: Transparency in experimental methodology, observation, collection of data and analytical methods. Public availability and re-usability of scientific data Public accessibility and transparency of scientific communication Using web-based tools to facilitate scientific collaboration By now all of you will (hopefully) be using R to explore and analyse your interesting data. As such, you’re already well along the road to making your analysis more reproducible, transparent and shareable. However, perhaps your current workflow looks something like this: Your data is imported from your favourite spreadsheet software into RStudio (or R), you write your R code to explore and analyse your data, you save plots as external files, copy tables of analysis output and then manually combine all of this and your written prose into a single MS Word document (maybe a paper or thesis chapter). Whilst there is nothing particularly wrong with this approach (and it’s certainly better than using point and click software to analyse your data) there are some limitations: It’s not particularly reproducible. Because this workflow separates your R code from the final document there are multiple opportunities for undocumented decisions to be made (which plots did you use? what analysis did/didn’t you include? etc). It’s inefficient. If you need to go back and change something (create a new plot or update your analysis etc) you will need to create or amend multiple documents increasing the risk of mistakes creeping into your workflow. It’s difficult to maintain. If your analysis changes you again need to update multiple files and documents. It can be difficult to decide what to share with others. Do you share all of your code (initial data exploration, model validation etc) or just the code specific to your final document? It’s quite a common (and bad!) practice for researchers to maintain two R scripts, one used for the actual analysis and one to share with the final paper or thesis chapter. This can be both time consuming and confusing and should be avoided. Perhaps a more efficient and robust workflow would look something like this: Your data is imported into RStudio (or R) as before but this time all of the R code you used to analyse your data, produce your plots and your written text (Introduction, Materials and Methods, Discussion etc) is contained within a single R markdown document which is then used (along with your data) to automatically create your final document. This is exactly what R markdown allows you to do. Some of the advantages of using R markdown include: Explicitly links your data with your R code and output creating a fully reproducible workflow. ALL of the R code used to explore, summarise and analyse your data can be included in a single easy to read document. You can decide what to include in your final document (as you will learn below) but all of your R code can be included in the R markdown document. You can create a wide variety of output formats (pdf, html web pages, MS Word and many others) from a single R markdown document which enhances both collaboration and communication. Enhances transparency of your research. Your data and R markdown file can be included with your publication or thesis chapter as supplementary material or hosted on a GitHub repository (see the GitHub Chapter). Increases the efficiency of your workflow. If you need to modify or extend your current analysis you just need to update your R markdown document and these changes will automatically be included in your final document. "],
["get-started-with-r-markdown.html", "7.3 Get started with R markdown", " 7.3 Get started with R markdown To use R markdown you will first need to install the rmarkdown package in RStudio (or in the R console if you’re not using RStudio) and any package dependencies. You can find instructions on how to do this for both Windows and Mac OSX operating systems here. If you would like to create pdf documents (or MS Word documents) from your R markdown file you will also need to install a version of LaTeX on your computer. If you’ve not installed LaTeX before, I recommend that you install TinyTeX. Again, instructions on how to do this can be found here. "],
["new-rm.html", "7.4 Create an R markdown document", " 7.4 Create an R markdown document Right, time to create your first R markdown document. Within RStudio, click on the menu File -&gt; New File -&gt; R Markdown.... In the pop up window, give the document a ‘Title’ and enter the ‘Author’ information (your name) and select HTML as the default output. We can change all of this later so don’t worry about it for the moment. You will notice that when your new R markdown document is created it includes some example R markdown code. Normally you would just highlight and delete everything in the document except the information at the top between the --- delimiters (this is called the YAML header which we will discuss in a bit) and then start writing your own code. However, just for now we will use this document to practice converting R markdown to both html and pdf formats and check everything is working. Once you’ve created your R markdown document it’s good practice to save this file somewhere convenient. You can do this by selecting File -&gt; Save from RStudio menu (or use the keyboard shortcut ctrl + s on Windows or cmd + s on a Mac) and enter an appropriate file name (maybe call it my_first_rmarkdown). Notice the file extension of your new R markdown file is .Rmd. Now, to convert your .Rmd file to a HTML document click on the little black triangle next to the Knit icon at the top of the source window and select knit to HTML RStudio will now ‘knit’ (or render) your .Rmd file into a HTML file. Notice that there is a new R Markdown tab in your console window which provides you with information on the rendering process and will also display any errors if something goes wrong. If everything went smoothly a new HTML file will have been created and saved in the same directory as your .Rmd file (ours will be called my_first_rmarkdown.html). To view this document simply double click on the file to open in a browser (like Chrome or Firefox) to display the rendered content. RStudio will also display a preview of the rendered file in a new window for you to check out (your window might look slightly different if you’re using a Windows computer). Great, you’ve just rendered your first R markdown document. If you want to knit your .Rmd file to a pdf document then all you need to do is choose knit to PDF instead of knit to HTML when you click on the knit icon. This will create a file called my_first_rmarkdown.pdf which you can double click to open. Give it a go! You can also knit an .Rmd file using the command line in the console rather than by clicking on the knit icon. To do this, just use the render() function from the rmarkdown package as shown below. Again, you can change the output format using the output_format= argument as well as many other options. library(rmarkdown) render(&#39;my_first_rmarkdown.Rmd&#39;, output_format = &#39;html_document&#39;) # alternatively if you don&#39;t want to load the rmarkdown package rmarkdown::render(&#39;my_first_rmarkdown.Rmd&#39;, output_format = &#39;html_document&#39;) # see ?render for more options "],
["r-markdown-anatomy.html", "7.5 R markdown anatomy", " 7.5 R markdown anatomy OK, now that you can render an R markdown file in RStudio into both HTML and pdf formats let’s take a closer look at the different components of a typical R markdown document. Normally each R markdown document is composed of 3 main components, 1) a YAML header, 2) formatted text and 3) one or more code chunks. 7.5.1 YAML header YAML stands for ‘YAML Ain’t Markup Language’ (it’s an ‘in’ joke!) and this optional component contains the metadata and options for the entire document such as the author name, date, output format, etc. The YAML header is surrounded before and after by a --- on its own line. In RStudio a minimal YAML header is automatically created for you when you create a new R markdown document as we did above but you can change this any time. A simple YAML header may look something like this: --- title: My first R markdown document author: Jane Doe date: March 01, 2020 output: html_document --- In the YAML header above the output format is set to HTML. If you would like to change the output to pdf format then you can change it from output: html_document to output: pdf_document (you can also set more than one output format if you like). You can also change the default font and font size for the whole document and even include fancy options such as a table of contents and inline references and a bibliography. If you want to explore the plethora of other options see here. Just a note of caution, many of the options you can specify in the YAML header will work with both HTML and pdf formatted documents, but not all. If you need multiple output formats for your R markdown document check whether your YAML options are compatible between these formats. Also, indentation in the YAML header has a meaning to be careful when aligning text. For example, if you want to include a table of contents you would modify the output: field in the YAML header as follows --- title: My first R markdown document author: Jane Doe date: March 01, 2020 output: html_document: toc: yes --- 7.5.2 Formatted text As mentioned above, one of the great things about R markdown is that you don’t need to rely on your word processor to bring your R code, analysis and writing together. R markdown is able to render (almost) all of the text formatting that you are likely to need such as italics, bold, strike-through, super and subscript as well as bulleted and numbered lists, headers and footers, images, links to other documents or web pages and also equations. However, in contrast to your familiar What-You-See-Is-What-You-Get (WYSIWYG) word processing software you don’t see the final formatted text in your R markdown document (as you would in MS Word), rather you need to ‘markup’ the formatting in your text ready to be rendered in your output document. At first, this might seem like a right pain in the proverbial but it’s actually very easy to do and also has many advantages (do you find yourself spending more time on making your text look pretty in MS Word rather than writing good content?!). Here is an example of marking up text formatting in an R markdown document #### Benthic Biodiversity experiment These data were obtained from a mesocosm experiment which aimed to examine the effect of benthic polychaete (*Nereis diversicolor*) biomass on sediment nutrient (NH~4~, NO~3~ and PO~3~) release. At the start of the experiment 15 replicate mesocosms were filled with 20 cm^2^ of **homogenised** marine sediment and assigned to one of five polychaete biomass treatments (0, 0.5, 1, 1.5, 2 g per mesocosm). which would look like this in the final rendered document (can you spot the markups?) Benthic Biodiversity experiment. These data were obtained from a mesocosm experiment which aimed to examine the effect of benthic polychaete (Nereis diversicolor) biomass on sediment nutrient (NH4, NO3 and PO3) release. At the start of the experiment replicate mesocosms were filled with 20 cm2 of homogenised marine sediment and assigned to one of five polychaete biomass treatments (0, 0.5, 1, 1.5, 2 g per mesocosm). 7.5.2.1 Emphasis Some of the most common R markdown syntax for providing emphasis and formatting text is given below. Goal R markdown output bold text **mytext** mytext italic text *mytext* mytext strikethrough ~~mytext~~ mytext superscript mytext^2^ mytext2 subscript mytext~2~ mytext2 Interestingly there is no underline R markdown syntax by default. I think this is because bold and italics are used to emphasise content (a semantic meaning) whereas an underline is considered a stylistic element (there may well be other reasons). If you really want to underline text you can use &lt;span style=&quot;text-decoration:underline&quot;&gt;underline this text&lt;/span&gt; for HTML output or $\\text{\\underline{This sentence underlined using \\LaTeX}}$ for pdf output. I just avoid underlining! 7.5.2.2 White space and line breaks One of the things that can be confusing for new users of R markdown is the use of spaces and carriage returns (the enter key on your keyboard). In R markdown multiple spaces within the text are generally ignored as are carriage returns. For example this R markdown text These data were obtained from a mesocosm experiment which aimed to examine the effect of benthic polychaete (*Nereis diversicolor*) biomass. will be rendered as These data were obtained from a mesocosm experiment which aimed to examine the effect of benthic polychaete (Nereis diversicolor) biomass. This is generally a good thing (no more random multiple spaces in your text). If you want your text to start on a new line then you can simply add two blank spaces at the end of the preceding line These data were obtained from a mesocosm experiment which aimed to examine the effect benthic polychaete (Nereis diversicolor) biomass. If you really want multiple spaces within your text and your output format is HTML then you can use the Non breaking space HTML tag &amp;nbsp; These &amp;nbsp; &amp;nbsp; &amp;nbsp; data were &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; obtained from a mesocosm experiment which &amp;nbsp; &amp;nbsp; aimed to examine the effect &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; benthic polychaete (*Nereis diversicolor*) biomass. These data were obtained from a mesocosm experiment which aimed to examine the effect benthic polychaete (Nereis diversicolor) biomass. 7.5.2.3 Headings You can add headings and subheadings to your R markdown document by using the # symbol at the beginning of the line. You can decrease the size of the headings by simply adding more # symbols. For example # Benthic Biodiversity experiment ## Benthic Biodiversity experiment ### Benthic Biodiversity experiment #### Benthic Biodiversity experiment ##### Benthic Biodiversity experiment ###### Benthic Biodiversity experiment results in headings in decreasing size order Benthic Biodiversity experiment. Benthic Biodiversity experiment. Benthic Biodiversity experiment. Benthic Biodiversity experiment. Benthic Biodiversity experiment. Benthic Biodiversity experiment. 7.5.2.4 Comments As you can see above the meaning of the # symbol is different when formatting text in an R markdown document compared to a standard R script (which is used to included a comment - remember?!). You can, however, use a # symbol to comment code inside a code chunk as usual (more about this in a bit). If you want to include a comment in your R markdown document outside a code chunk which won’t be included in the final rendered document then enclose your comment between &lt;!-- and --&gt;. &lt;!-- this is an example of how to format a comment using R markdown. --&gt; 7.5.2.5 Lists If you want to create a bullet point list of text you can format an unordered list with sub items. Notice that the sub-items need to be indented. - item 1 - item 2 + sub-item 2 + sub-item 3 - item 3 - item 4 item 1 item 2 sub-item 2 sub-item 3 item 3 item 4 If you need an ordered list 1. item 1 2. item 2 + sub-item 2 + sub-item 3 3. item 3 4. item 4 item 1 item 2 sub-item 2 sub-item 3 item 3 item 4 7.5.2.6 Images Another useful feature is the ability to embed images and links to web pages (or other documents) into your R markdown document. You can include images into your R markdown document in a number of different ways. Perhaps the simplest method is to use ![Cute grey kitten](images/Cute_grey_kitten.jpg) resulting in: Cute grey kitten The code above will only work if the image file (Cute_grey_kitten.jpg) is in the right place relative to where you saved your .Rmd file. In the example above the image file is in a sub directory (folder) called images in the directory where we saved our my_first_rmarkdown.Rmd file. You can embed images saved in many different file types but perhaps the most common are .jpg and .png. I think a more flexible way of including images in your document is to use the include_graphics() function from the knitr package as this gives finer control over the alignment and image size (it’s also works more or less the same with both HTML and pdf output formats). However, to do this you will need to include this R code in a ‘code chunk’ which we haven’t covered yet. Despite this I’ll leave the code here for later reference. This code center aligns the image and scales it to 50% of it’s original size. See ?include_graphics for more options. &#96;&#96;&#96;{r, echo=FALSE, fig.align='center', out.width='50%'} library(knitr) include_graphics(\"images/Cute_grey_kitten.jpg\") &#96;&#96;&#96; 7.5.2.7 Links In addition to images you can also include links to webpages or other links in your document. Use the following syntax to create a clickable link to an existing webpage. The link text goes between the square brackets and the URL for the webpage between the round brackets immediately after. You can include a text for your clickable [link](https://www.worldwildlife.org) which gives you: You can include a text for your clickable link 7.5.3 Code chunks Now to the heart of the matter. To include R code into your R markdown document you simply place your code into a ‘code chunk’. All code chunks start and end with three backticks ```. Note, these are also known as ‘grave accents’ or ’back quotes and are not the same as an apostrophe! On most keyboards you can find the backtick on the same key as tilde (~). &#96;&#96;&#96;{r} Any valid R code goes here &#96;&#96;&#96; You can insert a code chunk by either typing the chunk delimiters ```{r} and ``` manually or use the RStudio toolbar (the Insert button) or by clicking on the menu Code -&gt; Insert Chunk. Perhaps an even better way is to get familiar with the keyboard shortcuts Ctrl + Alt + I for Windows and Cmd + Option + I on MacOSX. There are a many things you can do with code chunks: you can produce text output from your analysis, create tables and figures and insert images amongst other things. Within the code chunk you can place rules and arguments between the curly brackets {} that give you control over how your code is interpreted and output is rendered. These are known as chunk options. The only mandatory chunk option is the first argument which specifies which language you’re using (r in our case but other languages are supported). Note, all of your chunk options must be written between the curly brackets on one line with no line breaks. You can also specify an optional code chunk name (or label) which can be useful when trying to debug problems and when performing advanced document rendering. In the following block we name the code chunk summary-stats, create a dataframe (dataf) with two variables x and y and then use the summary() function to display some summary statistics . When we run the code chunk both the R code and the resulting output are displayed in the final document. &#96;&#96;&#96;{r, summary-stats} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) summary(dataf) # x y # Min. : 1.00 Min. : 1.00 # 1st Qu.: 3.25 1st Qu.: 3.25 # Median : 5.50 Median : 5.50 # Mean : 5.50 Mean : 5.50 # 3rd Qu.: 7.75 3rd Qu.: 7.75 # Max. :10.00 Max. :10.00 When using chunk names make sure that you don’t have duplicate chunk names in your R markdown document and avoid spaces and full stops as this may cause problems when you come to knit your document (I use a - to separate words in my chunk names). If we wanted to only display the output of our R code (just the summary statistics for example) and not the code itself in our final document we can use the chunk option echo=FALSE &#96;&#96;&#96;{r, summary-stats, echo=FALSE} x # x y # Min. : 1.00 Min. : 1.00 # 1st Qu.: 3.25 1st Qu.: 3.25 # Median : 5.50 Median : 5.50 # Mean : 5.50 Mean : 5.50 # 3rd Qu.: 7.75 3rd Qu.: 7.75 # Max. :10.00 Max. :10.00 To display the R code but not the output use the results='hide' chunk option. &#96;&#96;&#96;{r, summary-stats, results='hide'} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) summary(dataf) Sometimes you may want to execute a code chunk without showing any output at all. You can suppress the entire output using the chunk option include=FALSE. &#96;&#96;&#96;{r, summary-stats, include=FALSE} x There are a large number of chunk options documented here with a more condensed version here. Perhaps the most commonly used are summarised below with the default values shown. Chunk option default value Function echo echo=TRUE If FALSE, will not display the code in the final document results results='markup' If ‘hide’, will not display the code’s results in the final document. If ‘hold’, will delay displaying all output pieces until the end of the chunk. If ‘asis’, will pass through results without reformatting them. include include=TRUE If FALSE, will run the chunk but not include the chunk in the final document. eval eval=TRUE If FALSE, will not run the code in the code chunk. message message=TRUE If FALSE, will not display any messages generated by the code. warning warning=TRUE If FALSE, will not display any warning messages generated by the code. 7.5.4 Adding figures By default, figures produced by R code will be placed immediately after the code chunk they were generated from. For example: &#96;&#96;&#96;{r, simple-plot} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) plot(dataf$x, dataf$y, xlab = &quot;x axis&quot;, ylab = &quot;y axis&quot;) If you want to change the plot dimensions in the final document you can use the fig.width= and fig.height= chunk options (in inches!). You can also change the alignment of the figure using the fig.align= chunk option. &#96;&#96;&#96;{r, simple-plot, fig.width=4, fig.height=3, fig.align='center'} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) plot(dataf$x, dataf$y, xlab = &quot;x axis&quot;, ylab = &quot;y axis&quot;) You can add a figure caption using the fig.cap= option. &#96;&#96;&#96;{r, simple-plot-cap, fig.cap=\"A simple plot\", fig.align='center'} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) plot(dataf$x, dataf$y, xlab = &quot;x axis&quot;, ylab = &quot;y axis&quot;) Figure 7.1: A simple plot If you want to suppress the figure in the final document use the fig.show='hide' option. &#96;&#96;&#96;{r, simple-plot, fig.show='hide'} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) plot(dataf$x, dataf$y, xlab = &quot;x axis&quot;, ylab = &quot;y axis&quot;) If you’re using a package like ggplot2 to create your plots then don’t forget you will need to make the package available with the library() function in the code chunk (or in a preceding code chunk). &#96;&#96;&#96;{r, simple-ggplot} x x &lt;- 1:10 # create an x variable y &lt;- 10:1 # create a y variable dataf &lt;- data.frame(x = x, y = y) library(ggplot2) ggplot(dataf, aes(x = x, y = y)) + geom_point() Again, there are a large number of chunk options specific to producing plots and figures. See here for more details. 7.5.5 Adding tables R markdown can print the contents of a dataframe as a table (or any other tabular object such as a summary of model output) by including the name of the dataframe in a code chunk. For example, to create a table of the first 10 rows of the inbuilt dataset iris &#96;&#96;&#96;{r, ugly-table} iris[1:10,] &#96;&#96;&#96; # Sepal.Length Sepal.Width Petal.Length Petal.Width Species # 1 5.1 3.5 1.4 0.2 setosa # 2 4.9 3.0 1.4 0.2 setosa # 3 4.7 3.2 1.3 0.2 setosa # 4 4.6 3.1 1.5 0.2 setosa # 5 5.0 3.6 1.4 0.2 setosa # 6 5.4 3.9 1.7 0.4 setosa # 7 4.6 3.4 1.4 0.3 setosa # 8 5.0 3.4 1.5 0.2 setosa # 9 4.4 2.9 1.4 0.2 setosa # 10 4.9 3.1 1.5 0.1 setosa But how ugly is that! You can create slightly nicer looking tables using native markdown syntax (this doesn’t need to be in a code chunk). | x | y | |:----------:|:----------:| | 1 | 5 | | 2 | 4 | | 3 | 3 | | 4 | 2 | | 5 | 1 | x y 1 5 2 4 3 3 4 2 5 1 The :-------: lets R markdown know that the line above should be treated as a header and the lines below as the body of the table. Alignment within the table is set by the position of the :. To center align use :------:, to left align :------ and right align ------:. Whilst it can be fun(!) to create tables with raw markup it’s only practical for very small and simple tables. The easiest way I know to include tables in an R markdown document is by using the kable() function from the knitr package (this should have already been installed when you installed the rmarkdown package). The kable() function can create tables for HTML, PDF and Word outputs. To create a table of the first 10 rows of the iris dataframe using the kable() function simply write your code block as &#96;&#96;&#96;{r, kable-table} library(knitr) kable(iris[1:10,]) &#96;&#96;&#96; Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa The kable() function offers plenty of options to change the formatting of the table. For example, if we want to round numeric values to one decimal place use the digits = argument. To center justify the table contents use align = 'c' and to provide custom column headings use the col.names = argument. See ?knitr::kable for more information. &#96;&#96;&#96;{r, kable-table2} kable(iris[1:10,], digits = 0, align = 'c', col.names = c('sepal length', 'sepal width', 'petal length', 'petal width', 'species')) &#96;&#96;&#96; sepal length sepal width petal length petal width species 5 4 1 0 setosa 5 3 1 0 setosa 5 3 1 0 setosa 5 3 2 0 setosa 5 4 1 0 setosa 5 4 2 0 setosa 5 3 1 0 setosa 5 3 2 0 setosa 4 3 1 0 setosa 5 3 2 0 setosa You can further enhance the look of your kable tables using the kableExtra package (don’t forget to install the package first!). See here for more details and a helpful tutorial. &#96;&#96;&#96;{r, kableExtra-table} library(kableExtra) kable(iris[1:10,]) %>% kable_styling(bootstrap_options = \"striped\", font_size = 10) &#96;&#96;&#96; Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa If you want even more control and customisation options for your tables take a look at the pander and xtable packages. 7.5.6 Inline R code Up till now we’ve been writing and executing our R code in code chunks. Another great reason to use R markdown is that we can also include our R code directly within our text. This is known as ‘inline code’. To include your code in your R markdown text you simply write `r write your r code here`. This can come in really useful when you want to include summary statistics within your text. For example, we could describe the iris dataset as follows: Morphological characteristics (variable names: `r names(iris)[1:4]`) were measured from `r nrow(iris)`*Iris sp.* plants from `r length(levels(iris$Species))` different species. The mean Sepal length was `r round(mean(iris$Sepal.Length), digits = 2)` mm. which would be rendered as Morphological characteristics (variable names: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) were measured from 150 iris plants from 3 different species. The mean Sepal length was 5.84 mm. The great thing about including inline R code in your text is that these values will automatically be updated if your data changes. "],
["tips-tricks.html", "7.6 Some tips and tricks", " 7.6 Some tips and tricks Problem : When rendering my R markdown document to pdf my code runs off the edge of the page. Solution: Add a global_options argument at the start of your .Rmd file in a code chunk: &#96;&#96;&#96;{r global_options, include=FALSE} knitr::opts_chunk$set(message=FALSE, tidy.opts=list(width.cutoff=60), tidy=TRUE) &#96;&#96;&#96; This code chunk won’t be displayed in the final document due to the include = FALSE argument and you should place the code chunk immediately after the YAML header to affect everything below that. tidy.opts = list(width.cutoff = 60), tidy=TRUE defines the margin cutoff point and wraps text to the next line. Play around with this value to get it right (60-80 should be OK for most documents). Problem: When I load a package in my R markdown document my rendered output contains all of the startup messages and/or warnings. Solution: You can load all of your packages at the start of your R markdown document in a code chunk along with setting your global options. &#96;&#96;&#96;{r global_options, include=FALSE} knitr::opts_chunk$set(message=FALSE, warning=FALSE, tidy.opts=list(width.cutoff=60)) suppressPackageStartupMessages(library(ggplot2)) &#96;&#96;&#96; The message=FALSE and warning=FALSE arguments suppress messages and warnings. The suppressPackageStartupMessages(library(ggplot2)) will load the ggplot2 package but suppress startup messages. Problem: When rendering my R markdown document to pdf my tables and/or figures are split over two pages. Solution: Add a page break using the LateX \\pagebreak notation before your offending table or figure Problem: The code in my rendered document looks ugly! Solution: Add the argument tidy=TRUE to your global arguments. Sometimes, however, this can cause problems especially with correct code indentation. &#96;&#96;&#96;{r global_options, include=FALSE} knitr::opts_chunk$set(message=FALSE, tidy.opts=list(width.cutoff=60), tidy=TRUE) &#96;&#96;&#96; "],
["further-information.html", "7.7 Further Information", " 7.7 Further Information Although we’ve covered more than enough to get you quite far using R markdown, as with most things R related, we’ve really only had time to scratch the surface. Happily, there’s a wealth of information available to you should you need to expand your knowledge and experience. A good place to start is the excellent free book written by the creator of R markdown Yihui Xie which you can find here. Another useful and concise R markdown reference guide can be found here A quick and easy RStudio R markdown cheatsheet "],
["github-r.html", "Chapter 8 Version control with Git and GitHub", " Chapter 8 Version control with Git and GitHub This Chapter will introduce you to the basics of using a version control system to keep track of all your important PhD documents and facilitate collaboration with colleagues and the wider world. The Chapter will focus on using the software ‘Git’ in combination with the web-based hosting service ‘GitHub’. By the end of the Chapter, you will be able to install and configure Git and GitHub on your computer and setup and work with a version controlled project in RStudio. We won’t be covering more advanced topics such as branching, forking and pull requests in much detail but I do give an overview later on in the Chapter. I estimate that this Chapter should take you roughly 1.5 to 2.5 hours to complete in one sitting (to be honest I have no idea really so this is just a guess), but feel free to dip in and out over a longer period if that suits you better. Just a few notes of caution. In this Chapter we’ll be using RStudio to interface with Git as it gives you a nice friendly graphical user interface which generally makes life a little bit easier (and who doesn’t want that?). However, one downside to using RStudio with Git is that RStudio only provides pretty basic Git functionality through its menu system. That’s fine for most of what we’ll be doing during this Chapter (although I will introduce a few Git commands as we go along) but if you really want to benefit from using Git’s power you will need to learn some Git commands and syntax. This leads me on to my next point. I’m not going to lie, Git can become a little bewildering and frustrating when you first start using it. This is mostly due to the terminology and liberal use of jargon associated with Git, but there’s no hiding the fact that it’s quite easy to get yourself and your Git repository into a pickle. Therefore, I have tried hard to keep things as straight forward as I can during this Chapter and as a result I do occasionally show you a couple of very ‘un-Git’ ways of doing things (mostly about reverting to previous versions of documents). Don’t get hung up about this, there’s no shame to using these low tech solutions and if it works then it works. Lastly, GitHub was not designed to host very large files and will warn you if you try to add files greater than 50 MB and block you adding files greater than 100 MB. If your project involves using large file sizes there are a few solutions but I find the easiest is to host these files elsewhere (Googledrive, Dropbox etc) and create a link to them in a README file or R markdown document on Github. "],
["what-is-version-control.html", "8.1 What is version control?", " 8.1 What is version control? A Version Control System (VCS) keeps a record of all the changes you make to your files that make up a particular project and allows you to revert to previous versions of files if you need to. To put it another way, if you muck things up or accidentally lose important files you can easily roll back to a previous stage in your project to sort things out. Version control was originally designed for collaborative software development, but it’s equally useful for scientific research and collaborations (although admittedly a lot of the terms, jargon and functionality are focused on the software development side). There are many different version control systems currently available, but we’ we’ll focus on using Git, because it’s free and open source and it integrates nicely with RStudio. This means that its can easily become part of your usual workflow with minimal additional overhead. "],
["why-use-version-control.html", "8.2 Why use version control?", " 8.2 Why use version control? So why should you worry about version control? Well, first of all it helps avoid this (familiar?) situation when you’re working on a project Figure 8.1: You need version control usually arising from this (familiar?) scenario Version control automatically takes care of keeping a record of all the versions of a particular file and allows you to revert back to previous versions if you need to. Version control also helps you (especially the future you) keep track of all your files in a single place and it helps others (especially collaborators) review, contribute to and reuse your work through the GitHub website. Lastly, your files are always available from anywhere and on any computer, all you need is an internet connection. "],
["what-is-git-and-github.html", "8.3 What is Git and GitHub?", " 8.3 What is Git and GitHub? Git is a version control system originally developed by [Linus Torvalds][linus] that lets you track changes to a set of files. These files can be any type of file including the menagerie of files that typically make up a data orientated project (.pdf, .Rmd, .docx, .txt, .jpg etc) although plain text files work the best. All the files that make up a project is called a repository (or just repo). GitHub is a web-based hosting service for Git repositories which allows you to create a remote copy of your local version-controlled project. This can be used as a backup or archive of your project or make it accessible to you and to your colleagues so you can work collaboratively. At the start of a project we typically (but not always) create a remote repository on GitHub, then clone (think of this as copying) this repository to our local computer (the one in front of you). This cloning is usually a one time event and you shouldn’t need to clone this repository again unless you really muck things up. Once you have cloned your repository you can then work locally on your project as usual, creating and saving files for your data analysis (scripts, R markdown documents, figures etc). Along the way you can take snapshots (called commits) of these files after you’ve made important changes. We can then push these changes to the remote GitHub repository to make a backup or make available to our collaborators. If other people are working on the same project (repository), or maybe you’re working on a different computer, you can pull any changes back to your local repository so everything is synchronised. "],
["setup-git.html", "8.4 Getting started", " 8.4 Getting started This Chapter assumes that you have already installed the latest versions of R and RStudio. If you haven’t done this yet you can find instructions here. 8.4.1 Install Git To get started, you first need to install Git. If you’re lucky you may already have Git installed (especially if you have a Mac or Linux computer). You can check if you already have Git installed by clicking on the Terminal tab in the Console window in RStudio and typing git --version (the space after the git command is important). If you see something that looks like git version 2.25.0 (the version number may be different on your computer) then you already have Git installed (happy days). If you get an error (something like git: command not found) this means you don’t have Git installed (yet!). You can also do this check outside RStudio by opening up a separate Terminal if you want. On Windows go to the ‘Start menu’ and in the search bar (or run box) type cmd and press enter. On a Mac go to ‘Applications’ in Finder, click on the ‘Utilities’ folder and then on the ‘Terminal’ program. On a Linux machine simply open the Terminal (Ctrl+Alt+T often does it). To install Git on a Windows computer we recommend you download and install Git for Windows (also known as ‘Git Bash’). You can find the download file and installation instructions here. For those of you using a Mac computer we recommend you download Git from here and install in the usual way (double click on the installer package once downloaded). If you’ve previously installed Xcode on your Mac and want to use a more up to date version of Git then you will need to follow a few more steps documented [here][git-xcode]. If you’ve never heard of Xcode then don’t worry about it! For those of you lucky enough to be working on a Linux machine you can simply use your OS package manager to install Git from the official repository. For Ubuntu Linux (or variants of) open your Terminal and type sudo apt update sudo apt install git You will need administrative privileges to do this. For other versions of Linux see here for further installation instructions. Whatever version of Git you’re installing, once the installation has finished verify that the installation process has been successful by running the command git --version in the Terminal tab in RStudio (as described above). On some installations of Git (yes I’m looking at you MS Windows) this may still produce an error as you will also need to setup RStudio so it can find the Git executable (described below). 8.4.2 Configure Git After installing Git, you need to configure it so you can use it. Click on the Terminal tab in the Console window again and type the following: git config --global user.email &#39;you@youremail.com&#39; git config --global user.name &#39;Your Name&#39; substituting 'Your Name' for your actual name and 'you@youremail.com' with your email address. We recommend you use your University email address as you will also use this address when you register for your GitHub account (coming up in a bit). If this was successful, you should see no error messages from these commands. To verify that you have successfully configured Git type the following into the Terminal git config --global --list You should see both your user.name and user.email configured. 8.4.3 Configure RStudio As you can see above, Git can be used from the command line, but it also integrates well with RStudio, providing a friendly graphical user interface. If you want to use RStudio’s Git integration (we recommend you do - at least at the start), you need to check that the path to the Git executable is specified correctly. In RStudio, go to the menu Tools -&gt; Global Options -&gt; Git/SVN and make sure that ‘Enable version control interface for RStudio projects’ is ticked and that the ‘Git executable:’ path is correct for your installation. If it’s not correct hit the Browse... button and navigate to where you installed git and click on the executable file. You will need to restart RStudio after doing this. 8.4.4 Register a GitHub account If all you want to do is to keep track of files and file versions on your local computer then Git is sufficient. If however, you would like to make an off-site copy of your project or make it available to your collaborators then you will need a web-based hosting service for your Git repositories. This is where GitHub comes into play (there are also other services like GitLab, Bitbucket and Savannah). You can sign up for a free account on GitHub here. You will need to specify a username, an email address and a strong password. We suggest that you use your University email address (if you have one) as this will also allow you to apply for a free educator or researcher account later on which gives you some useful benefits (don’t worry about this now though). When it comes to choosing a username we suggest you give this some thought. Choose a short(ish) rather than a long username, use all lowercase and hyphenate if you want to include multiple words, find a way of incorporating your actual name and lastly, choose a username that you will feel comfortable revealing to your future employer! Next click on the ‘Select a plan’ (you may have to solve a simple puzzle first to verify you’re human) and choose the ‘Free Plan’ option. Github will send an email to the email address you supplied for you to verify. Once you’ve completed all those steps you should have both Git and GitHub setup up ready for you to use (Finally!). "],
["setting-up-a-project-in-rstudio.html", "8.5 Setting up a project in RStudio", " 8.5 Setting up a project in RStudio Now that you’re all set up, let’s create your first version controlled RStudio project. There are a couple of different approaches you can use to do this. You can either setup a remote GitHub repository first then connect an RStudio project to this repository (we’ll call this Option 1). Another option is to setup a local repository first and then link a remote GitHub repository to this repository (Option 2). You can also connect an existing project to a GitHub repository but we won’t cover this here. I suggest that if you’re completely new to Git and GitHub then use Option 1 as this approach sets up your local Git repository nicely and you can push and pull immediately. Option 2 requires a little more work and therefore there are more opportunities to go wrong. We will cover both of these options below. 8.5.1 Option 1 - GitHub first To use the GitHub first approach you will first need to create a repository (repo) on GitHub. Go to your GitHub page and sign in if necessary. Click on the ‘Repositories’ tab at the top and then on the green ‘New’ button on the right Give your new repo a name (let’s call it first_repo for this Chapter), select ‘Public’, tick on the ‘Initialize this repository with a README’ (this is important) and then click on ‘Create repository’ (ignore the other options for now). Your new GitHub repository will now be created. Notice the README has been rendered in GitHub and is in markdown (.md) format (see Chapter 7 on R markdown if this doesn’t mean anything to you). Next click on the green ‘Clone or Download’ button and copy the https//... URL that pops up for later (either highlight it all and copy or click on the copy to clipboard icon to the right). Ok, we now switch our attention to RStudio. In RStudio click on the File -&gt; New Project menu. In the pop up window select Version Control. Now paste the the URL you previously copied from GitHub into the Repository URL: box. This should then automatically fill out the Project Directory Name: section with the correct repository name (it’s important that the name of this directory has the same name as the repository you created in GitHub). You can then select where you want to create this directory by clicking on the Browse button opposite the Create project as a subdirectory of: option. Navigate to where you want the directory created and click OK. I also tick the Open in new session option. RStudio will now create a new directory with the same name as your repository on your local computer and will then clone your remote repository to this directory. The directory will contain three new files; first_repo.Rproj (or whatever you called your repository), README.md and .gitignore. You can check this out in the Files tab usually in the bottom right pane in RStudio. You will also have a Git tab in the top right pane with two files listed (we will come to this later on in the Chapter). That’s it for Option 1, you now have a remote GitHub repository set up and this is linked to your local repository managed by RStudio. Any changes you make to files in this directory will be version controlled by Git. 8.5.2 Option 2 - RStudio first An alternative approach is to create a local RStudio project first and then link to a remote Github repository. As I mentioned before, this option is more involved than Option 1 so feel free to skip this now and come back later to it if you’re interested. This option is also useful if you just want to create a local RStudio project linked to a local Git repository (i.e. no GitHub involved). If you want to do this then just follow the instructions below omitting the GitHub bit. In RStudio click on the File -&gt; New Project menu and select the New Directory option. In the pop up window select the New Project option In the New Project window specify a Directory name (choose second_repo for this Chapter) and select where you would like to create this directory on you computer (click the Browse button). Make sure the Create a git repository option is ticked This will create a version controlled directory called second_repo on your computer that contains two files, second_repo.Rproj and .gitignore (there might also be a .Rhistory file but ignore this). You can check this by looking in the Files tab in RStudio (usually in the bottom right pane). OK, before we go on to create a repository on GitHub we need to do one more thing - we need to place our second_repo.Rproj and .gitignorefiles under version control. Unfortunately we haven’t covered this in detail yet so just follow the next few instructions (blindly!) and we’ll revisit them in the Using Git section of this Chapter. To get our two files under version control click on the ‘Git’ tab which is usually in the top tight pane in RStudio You can see that both files are listed. Next, tick the boxes under the ‘Staged’ column for both files and then click on the ‘Commit’ button. This will take you to the ‘Review Changes’ window. Type in the commit message ‘First commit’ in the ‘Commit message’ window and click on the ‘Commit’ button. A new window will appear with some messages which you can ignore for now. Click ‘Close’ to close this window and also close the ‘Review Changes’ window. The two files should now have disappeared from the Git pane in RStudio indicating a successful commit. OK, that’s those two files now under version control. Now we need to create a new repository on GitHub. In your browser go to your GitHub page and sign in if necessary. Click on the ‘Repositories’ tab and then click on the green ‘New’ button on the right. Give your new repo the name second_repo (the same as your version controlled directory name) and select ‘Public’. This time do not tick the ‘Initialize this repository with a README’ (this is important) and then click on ‘Create repository’. This will take you to a Quick setup page which provides you with some code for various situations. The code we are interested in is the code under ...or push an existing repository from the command line heading. Highlight and copy the first line of code (note: yours will be slightly different as it will include your GitHub username not mine) git remote add origin https://github.com/alexd106/second_repo.git Switch to RStudio, click on the ‘Terminal’ tab and paste the command into the Terminal. Now go back to GitHub and copy the second line of code git push -u origin master and paste this into the Terminal in RStudio. You should see something like this If you take a look at your repo back on GitHub (click on the /second_repo link at the top) you will see the second_repo.Rproj and .gitignore files have now been pushed to GitHub from your local repository. The last thing we need to do is create and add a README file to your repository. A README file describes your project and is written using the same Markdown language you learned in the R markdown Chapter. A good README file makes it easy for others (or the future you!) to use your code and reproduce your project. You can create a README file in RStudio or in GitHub. Let’s use the second option. In your repository on GitHub click on the green Add a README button. Now write a short description of your project in the &lt;&gt; Edit new file section and then click on the green Commit new file button. You should now see the README.md file listed in your repository. It won’t actually exist on your computer yet as you will need to pull these changes back to your local repository, but more about that in the next section. Whether you followed Option 1 or Option 2 (or both) you have now successfully setup a version controlled RStudio project (and associated directory) and linked this to a GitHub repository. Git will now monitor this directory for any changes you make to files and also if you add or delete files. If the steps above seem like a bit of an ordeal, just remember, you only need to do this once for each project and it gets much easier over time. "],
["use-git.html", "8.6 Using Git", " 8.6 Using Git Now that we have our project and repositories (both local and remote) set up, it’s finally time to learn how to use Git in RStudio! Typically, when using Git your workflow will go something like this: You create/delete and edit files in your project directory on your computer as usual (saving these changes as you go) Once you’ve reached a natural ‘break point’ in your progress (i.e. you’d be sad if you lost this progress) you stage these files You then commit the changes you made to these staged files (along with a useful commit message) which creates a permanent snapshot of these changes You keep on with this cycle until you get to a point when you would like to push these changes to GitHub If you’re working with other people on the same project you may also need to pull their changes to your local computer OK, let’s go through an example to help clarify this workflow. In RStudio open up the first_repo.Rproj you created previously during Option 1. Either use the File -&gt; Open Project menu or click on the top right project icon and select the appropriate project. Create an R markdown document inside this project by clicking on the File -&gt; New File -&gt; R markdown menu (remember from the R markdown Chapter?). Once created, we can delete all the example R markdown code (except the YAML header) as usual and write some interesting R markdown text and include a plot. We’ll use the inbuilt cars dataset to do this. Save this file (cmd + s for Mac or ctrl + s in Windows). Your R markdown document should look something like the following (it doesn’t matter if it’s not exactly the same). Take a look at the ‘Git’ tab which should list your new R markdown document (first_doc.Rmd in this example) along with first_repo.Rproj, and .gitignore (you created these files previously when following Option 1). Following our workflow, we now need to stage these files. To do this tick the boxes under the ‘Staged’ column for all files. Notice that there is a status icon next to the box which gives you an indication of how the files were changed. In our case all of the files are to be added (capital A) as we have just created them. After you have staged the files the next step is to commit the files. This is done by clicking on the ‘Commit’ button. After clicking on the ‘Commit’ button you will be taken to the ‘Review Changes’ window. You should see the three files you staged from the previous step in the left pane. If you click on the file name first_doc.Rmd you will see the changes you have made to this file highlighted in the bottom pane. Any content that you have added is highlighted in green and deleted content is highlighted in red. As you have only just created this file, all the content is highlighted in green. To commit these files (take a snapshot) first enter a mandatory commit message in the ‘Commit message’ box. This message should be relatively short and informative (to you and your collaborators) and indicate why you made the changes, not what you changed. This makes sense as Git keeps track of what has changed and so it is best not to use commit messages for this purpose. It’s traditional to enter the message ‘First commit’ (or ‘Initial commit’) when you commit files for the first time. Now click on the ‘Commit’ button to commit these changes. A summary of the commit you just performed will be shown. Now click on the ‘Close’ button to return to the ‘Review Changes’ window. Note that the staged files have now been removed. Now that you have committed your changes the next step is to push these changes to GitHub. Before you push your changes it’s good practice to first pull any changes from GitHub. This is especially important if both you and your collaborators are working on the same files as it keeps you local copy up to date and avoids any potential conflicts. In this case your repository will already be up to date but it’s a good habit to get into. To do this, click on the ‘Pull’ button on the top right of the ‘Review Changes’ window. Once you have pulled any changes click on the green ‘Push’ button to push your changes. You will see a summary of the push you just performed. Hit the ‘Close’ button and then close the ‘Review Changes’ window. To confirm the changes you made to the project have been pushed to GitHub, open your GitHub page, click on the Repositories link and then click on the first_repo repository. You should see four files listed including the first_doc.Rmd you just pushed. Along side the file name you will see your last commit message (‘First commit’ in this case) and when you made the last commit. To see the contents of the file click on the first_doc.Rmd file name. 8.6.1 Tracking changes After following the steps outlined above, you will have successfully modified an RStudio project by creating a new R markdown document, staged and then committed these changes and finally pushed the changes to your GitHub repository. Now let’s make some further changes to your R markdown file and follow the workflow once again but this time we ’ll take a look at how to identify changes made to files, examine the commit history and how to restore to a previous version of the document. In RStudio open up the first_repo.Rproj file you created previously (if not already open) then open the first_doc.Rmd file (click on the file name in the Files tab in RStudio). Let’s make some changes to this document. Delete the line beginning with ‘My first version controlled …’ and replace it with something more informative (see figure below). We will also change the plotted symbols to red and give the plot axes labels. Lastly, let’s add a summary table of the dataframe using the kable() and summary() functions (you may need to install the knitr package if you haven’t done so previously to use the kable() function) and finally render this document to pdf by changing the YAML option to output: pdf_document. Now save these changes and then click the knit button to render to pdf. A new pdf file named first_doc.pdf will be created which you can view by clicking on the file name in the Files tab in RStudio. Notice that these two files have been added to the Git tab in RStudio. The status icons indicate that the first_doc.Rmd file has been modified (capital M) and the first_doc.pdf file is currently untracked (question mark). To stage these files tick the ‘Staged’ box for each file and click on the ‘Commit’ button to take you to the ‘Review Changes’ window Before you commit your changes notice the status of first_doc.pdf has changed from untracked to added (A). You can view the changes you have made to the first_doc.Rmd by clicking on the file name in the top left pane which will provide you with a useful summary of the changes in the bottom pane (technically called diffs). Lines that have been deleted are highlighted in red and lines that have been added are highlighted in green (note that from Git’s point of view, a modification to a line is actually two operations: the removal of the original line followed by the creation of a new line). Once you’re happy, commit these changes by writing a suitable commit message and click on the ‘Commit’ button. To push the changes to GitHub, click on the ‘Pull’ button first (remember this is good practice even though you are only collaborating with yourself at the moment) and then click on the ‘Push’ button. Go to your online GitHub repository and you will see your new commits, including the first_doc.pdf file you created when you rendered your R markdown document. To view the changes in first_doc.Rmd click on the file name for this file. 8.6.2 Commit history One of the great things about Git and GitHub is that you can view the history of all the commits you have made along with the associated commit messages. You can do this locally using RStudio (or the Git command line) or if you have pushed your commits to GitHub you can check them out on the GitHub website. To view your commit history in RStudio click on the ‘History’ button (the one that looks like a clock) in the Git pane to bring up the history view in the ‘Review Changes’ window. You can also click on the ‘Commit’ or ‘Diff’ buttons which takes you to the same window (you just need to additionally click on the ‘History’ button in the ‘Review Changes’ window). The history window is split into two parts. The top pane lists every commit you have made in this repository (with associated commit messages) starting with the most recent one at the top and oldest at the bottom. You can click on each of these commits and the bottom pane shows you the changes you have made along with a summary of the Date the commit was made, Author of the commit and the commit message (Subject). There is also a unique identifier for the commit (SHA - Secure Hash Algorithm) and a Parent SHA which identifies the previous commit. These SHA identifiers are really important as you can use them to view and revert to previous versions of files (details below). You can also view the contents of each file by clicking on the ‘View file @ SHA key` link (in our case ’View file @ 2b4693d1’). You can also view your commit history on GitHub website but this will be limited to only those commits you have already pushed to GitHub. To view the commit history navigate to the repository and click on the ‘commits’ link (in our case the link will be labelled ‘3 commits’ as we have made 3 commits). You will see a list of all the commits you have made, along with commit messages, date of commit and the SHA identifier (these are the same SHA identifiers you saw in the RStudio history). You can even browse the repository at a particular point in time by clicking on the &lt;&gt; link. To view the changes in files associated with the commit simply click on the relevant commit link in the list. Which will display changes using the usual format of green for additions and red for deletions. 8.6.3 Reverting changes One the great things about using Git is that you are able to revert to previous versions of files if you’ve made a mistake, broke something or just prefer and earlier approach. How you do this will depend on whether the changes you want to discard have been staged, committed or pushed to GitHub. We’ll go through some common scenarios below mostly using RStudio but occasionally we will need to resort to using the Terminal (still in RStudio though). 8.6.3.1 Changes saved but not staged, committed or pushed If you have saved changes to your file(s) but not staged, committed or pushed these files to GitHub you can right click on the offending file in the Git pane and select ‘Revert …’. This will roll back all of the changes you have made to the same state as your last commit. Just be aware that you cannot undo this operation so use with caution. You can also undo changes to just part of a file by opening up the ‘Diff’ window (click on the ‘Diff’ button in the Git pane). Select the line you wish to discard by double clicking on the line and then click on the ‘Discard line’ button. In a similar fashion you can discard chunks of code by clicking on the ‘Discard chunk’ button. 8.6.3.2 Staged but not committed and not pushed If you have staged your files, but not committed them then simply unstage them by clicking on the ‘Staged’ check box in the Git pane (or in the ‘Review Changes’ window) to remove the tick. You can then revert all or parts of the file as described in the section above. 8.6.3.3 Staged and committed but not pushed If you have made a mistake or have forgotten to include a file in your last commit which you have not yet pushed to GitHub, you can just fix your mistake, save your changes, and then amend your previous commit. You can do this by staging your file and then tick the ‘Amend previous commit` box in the ’Review Changes’ window before committing. If we check out our commit history you can see that our latest commit contains both changes to the file rather than having two separate commits. I use the amend commit approach alot but it’s important to understand that you should not do this if you have already pushed your last commit to GitHub as you are effectively rewriting history and all sorts bad things may happen! If you spot a mistake that has happened multiple commits back or you just want to revert to a previous version of a document you have a number of options. Option 1 - (probably the easiest but very unGit - but like, whatever!) is to look in your commit history in RStudio, find the commit that you would like to go back to and click on the ‘View file @’ button to show the file contents. You can then copy the contents of the file to the clipboard and paste it into your current file to replace your duff code or text. Alternatively, you can click on the ‘Save As’ button and save the file with a different file name. Once you have saved your new file you can delete your current unwanted file and then carry on working on your new file. Don’t forget to stage and commit this new file. Option 2 - (Git like) Go to your Git history, find the commit you would like to roll back to and write down (or copy) its SHA identifier. Now go to the Terminal in RStudio and type git checkout &lt;SHA&gt; &lt;filename&gt;. In our case the SHA key is 2b4693d1 and the filename is first_doc.Rmd so our command would look like this: git checkout 2b4693d1 first_doc.Rmd The command above will copy the selected file version from the past and place it into the present. RStudio may ask you whether you want to reload the file as it now changed - select yes. You will also need to stage and commit the file as usual. If you want to revert all your files to the same state as a previous commit rather than just one file you can use (the single ‘dot’ . is important otherwise your HEAD will detach!): git rm -r . git checkout 2b4693d1 . Note that this will delete all files that you have created since you made this commit so be careful! 8.6.3.4 Staged, committed and pushed If you have already pushed your commits to GitHub you can use the git checkout strategy described above and then commit and push to update GitHub (although this is not really considered ‘best’ practice). Another approach would be to use git revert (Note: as far as I can tell git revert is not the same as the ‘Revert’ option in RStudio). The revert command in Git essentially creates a new commit based on a previous commit and therefore preserves all of your commit history. To rollback to a previous state (commit) you first need to identify the SHA for the commit you wish to go back to (as we did above) and then use the revert command in the Terminal. Let’s say we want to revert back to our ‘First commit’ which has a SHA identifier d27e79f1. We can use the revert command as shown below in the Terminal. The --no-commit option is used to prevent us from having to deal with each intermediate commit. git revert --no-commit d27e79f1..HEAD Your first_doc.Rmd file will now revert back to the same state as it was when you did your ‘First commit’. Notice also that the first_doc.pdf file has been deleted as this wasn’t present when we made our first commit. You can now stage and commit these files with a new commit message and finally push them to GitHub. Notice that if we look at our commit history all of the commits we have made are still present. and our repo on GitHub also reflects these changes 8.6.4 Collaborate with Git GitHub is a great tool for collaboration, it can seem scary and complicated at first, but it is worth investing some time to learn how it works. What makes GitHub so good for collaboration is that it is a distributed system, which means that every collaborator works on their own copy of the project and changes are then merged together in the remote repository. There are two main ways you can set up a collaborative project on GitHub. One is the workflow we went through above, where everybody connects their local repository to the same remote one; this system works well with small projects where different people mainly work on different aspects of the project but can quickly become unwieldy if many people are collaborating and are working on the same files (merge misery!). The second approach consists of every collaborator creating a copy (or fork) of the main repository, which becomes their remote repository. Every collaborator then needs to send a request (a pull request) to the owner of the main repository to incorporate any changes into the main repository and this includes a review process before the changes are integrated. More detail of these topics can be found in the Further resources section. 8.6.5 Git tips Generally speaking you should commit often (including amended commits) but push much less often. This makes collaboration easier and also makes the process of reverting to previous versions of documents much more straight forward. I generally only push changes to GitHub when I’m happy for my collaborators (or the rest of the world) to see my work. However, this is entirely up to you and depends on the project (and who you are working with) and what your priorities are when using Git. If you don’t want to track a file in your repository (maybe they are too large or transient files) you can get Git to ignore the file by right clicking on the filename in the Git pane and selecting ‘Ignore…’ This will add the filename to the .gitignore file. If you want to ignore multiple files or a particular type of file you can also include wildcards in the .gitignore file. For example to ignore all png files you can include the expression *.png in your .gitignore file and save. If it all goes pear shaped and you end up completely trashing your Git repository don’t despair (we’ve all been there!). As long as your GitHub repository is good, all you need to do is delete the offending project directory on your computer, create a new RStudio project and link this with your remote GitHub repository using Option 2. Once you have cloned the remote repository you should be good to go. "],
["resources.html", "8.7 Further resources", " 8.7 Further resources There are many good online guides to learn more about git and GitHub and as with any open source software there is a huge community that can be a great resource: The British Ecological Society guide to Reproducible Code The GitHub guides The Mozilla Science Lab GitHub for Collaboration on Open Projects guide Jenny Bryan’s Happy Git and GitHub If you have done something terribly wrong and don’t know how to fix it try Oh Shit, Git or if you’re easily offended Dangit, Git These are only a couple of examples, all you need to do is Google “version control with git and GitHub” to see how huge the community around these open source projects is and how many free resources are available for you to become a version control expert. "],
["appendix.html", "Chapter 9 Appendix", " Chapter 9 Appendix "],
["install-rm.html", "9.1 Installing R Markdown", " 9.1 Installing R Markdown 9.1.1 MS Windows This guide assumes you have already installed R and the RStudio IDE. RStudio is not required but recommended, because it makes it easier to work with R Markdown. If you don’t have RStudio IDE installed, you will also have to install Pandoc. If you have RStudio installed there is no need to install Pandoc separately because it’s bundled with RStudio. Next you can install the rmarkdown package in RStudio using the following code: # Install from CRAN install.packages(&#39;rmarkdown&#39;, dep = TRUE) The dep = TRUE argument will also install a bunch of additional R packages on which rmarkdown depends. If you want to generate PDF output, you will need to install LaTeX. For R Markdown users who have not installed LaTeX before, we recommend that you install TinyTeX. You can install TinyTex from within RStudio using the following code: install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() # install TinyTeX TinyTeX is a lightweight, portable, cross-platform, and easy-to-maintain LaTeX distribution. The R companion package tinytex can help you automatically install missing LaTeX packages when compiling LaTeX or R Markdown documents to PDF. An alternative option would be to install MiKTeX instead. You can download the latest distribution of [MiKTeX][miktex]. Installing MiKTeX is pretty straight forward, but it can sometimes be a pain to get it to play nicely with RStudio. If at all possible we recommend that you use TinyTex. With the rmarkdown package, RStudio/Pandoc, and LaTeX, you should be able to compile most R Markdown documents. 9.1.2 Mac OSX This guide assumes you have already installed [R][R] and the RStudio IDE. RStudio is not required but recommended, because it makes it easier to work with R Markdown. If you do not have RStudio IDE installed, you will also have to install Pandoc. If you have RStudio installed there is no need to install Pandoc separately because its bundled with RStudio. Next you can install the rmarkdown package in RStudio using the following code: # Install from CRAN install.packages(&#39;rmarkdown&#39;, dep = TRUE) The dep = TRUE argument will also install a bunch of additional R packages on which rmarkdown depends. If you want to generate PDF output, you will need to install LaTeX. For R Markdown users who have not installed LaTeX before, we recommend that you install TinyTeX. You can install TinyTex from within RStudio using the following code: install.packages(&#39;tinytex&#39;) tinytex::install_tinytex() # install TinyTeX TinyTeX is a lightweight, portable, cross-platform, and easy-to-maintain LaTeX distribution. The R companion package tinytex can help you automatically install missing LaTeX packages when compiling LaTeX or R Markdown documents to PDF. If for some reason TinyTeX does not work on your Mac computer then you can try to install MacTeX instead. You can download the latest version of MacTeX. Click on the MacTeX.pkg link to download. Please be aware that the file is quite large, approximately 3 GB, so it may take some time (also make sure you have enough available space on your computer hard disk). When your download is complete, run the downloaded installer. The installation procedure is quite straightforward. You are given a few options, for example you can choose not to install some components. I recommend you stick with the default settings, so having accepted the license agreement, you can basically just keep clicking ‘Continue’ on each screen. On the final screen of the wizard, click Install. It may ask for an administrator password. Enter the password, click ‘Install Software’ and go make a cup of coffee while the installation completes. When the program is done installing, click ‘Close’ to complete the installation. With the rmarkdown package, RStudio/Pandoc, and LaTeX, you should be able to compile most R Markdown documents. "]
]

[
["index.html", "A Introduction to R Preface", " A Introduction to R Alex Douglas, Francesca Mancini, Deon Roos, Ana Couto &amp; David Lusseau December 21, 2019 Preface The purpose of this book is to introduce you to using R, a powerful and flexible interactive environment for statistical computing and research. R in itself is not difficult to learn, but as with learning any new language (spoken or computer) the initial learning curve can be a little steep and somewhat daunting. We have tried to simplify the content of this book as much as possible and have based it on our own personal experience of teaching (and learning) R over the last 15 years. It is not intended to cover everything there is to know about R - that would be an impossible task. Neither is it intended to be an introductory statistics course, although you will be using some simple statistics to highlight some of R’s capabilities. The main aim of this book is to help you climb the initial learning curve and provide you with the basic skills and experience (and confidence!) to enable you to further your experience in using R. A few notes about this book. Although you can use this book as a standalone resource, we strongly recommend you use it in conjunction with the companion website. The course website contains a series of exercises which will help you practice writing R code and test your understanding of key concepts - you certainly won’t learn how to use R by watching other people do it (or reading a book about it!). The website also contains solutions for each of the exercises and a plethora of links to additional resources. A question we get asked fairly regularly is ‘what’s the best/easiest way to learn R?’. Unfortunately, we don’t have a ready answer to this question as everyone tends to learn R in their own way and at their own pace. Having said that, here are a few things to bear in mind that might help: Use R often and use it regularly - find any excuse to fire up R (or RStudio) and get coding to help build and maintain all important momentum. Learning R is not a memory test. One of the beauties of a scripting language is that you will always have your code to refer back to when you inevitably forget how to do something. You don’t need to know everything there is to know about R to use it productively. If you get stuck, Google it, it’s not cheating and writing a good search query is a skill in itself. Just make sure you check thoroughly that the code you find is doing what you want it to do. If you find yourself staring at code for hours trying to find out why it’s not working then walk away for a few minutes. I have lost count of the number of times I was able to spot my mistake almost immediately after returning from a short caffeine break. In R there are many ways to tackle a particular problem. If your code doesn’t look like someone else’s, but it does what you want it to do in a reasonable time and robustly then don’t worry about it - job done. Related to the previous point, remember R is just a tool to help you answer your interesting questions. Although it can be fun to immerse yourself in all things R, don’t lose sight of what’s important - your research question(s) and your data. No amount of skill using R will help if your data collection is fundamentaly flawed or your question vague. Recognise that there will be times when things will get a little tough or frustrating. Try to accept these periods as part of the natural process of learning how to use R (we’ve all been there) and remember, the time and energy you invest now will be more than payed back in the not too distant future. Finally, once you have finished working your way through this book, we encourage you to practice what you’ve learned using your own data. If you don’t have any data yet, then ask your colleagues / friends / family for some (I’m sure they will be delighted!) or follow one of the many excellent tutorials available on-line (see the course website for more details). Our suggestion to you, is that while you are getting to grips with R, uninstall any other statistics software you have on your computer and only use R. This may seem a little extreme but will hopefully remove the temptation to ‘just do it quickly’ in a more familiar environment and consequently slow down your learning of R. Believe us, anything you can do in your existing statistics software package you can do in R - often more robustly and efficiently. Good luck and have don’t forget to have fun. This book is written in RMarkdown and published with bookdown. "],
["getting-started-with-r-and-rstudio.html", "Chapter 1 Getting started with R and RStudio", " Chapter 1 Getting started with R and RStudio Although R is not new, it’s popularity has increased rapidly over the last 10 years or so (see here for some interesting data). It was originally created and developed by Ross Ihaka and Robert Gentleman during the 1990’s with the first stable version released in 2000. Nowadays R is currently maintained by the R Development Core Team. So, why has R become so popular and why should you learn how to use it? Some reasons include: R is open source and freely available. R is available for Windows, Mac and Linux operating systems. R has an extensive and coherent set of tools for statistical analysis. R has an extensive and highly flexible graphical facility capable of producing publication quality figures. R has an expanding set of freely available ‘packages’ to extend R’s capabilities. R has an extensive support network with numerous online and freely available documents. All of the reasons above are great reasons to use R. However, in our opinion, the single biggest reason to use R is that it facilitates robust and reproducible research practices. In contrast to more traditional ‘point and click’ software, writing R code to perform your analysis ensures you have a permanent and accurate record of all the methods you used (and decisions you made) whilst analysing your data. You are then able to share this code (and your data) with other researchers / colleagues / journal reviewers who will be able to reproduce your analysis exactly. This is one of the tenets of open science. We will cover other topics to facilitate open science throughout this book, including creating reproducible reports and version control. "],
["install-r.html", "1.1 Installing R", " 1.1 Installing R To get up and running the first thing you need to do is install R. R is freely available for Windows, Mac and Linux operating systems from the Comprehensive R Archive Network (CRAN) website. For Windows and Mac users we suggest you download and install the precompiled binary versions. 1.1.1 Windows users For Windows users select ‘Download R for Windows’ link and then click on the ‘base’ link and finally the download link ‘Download R 3.X.X for Windows’ (where 3.X.X is the latest version of the binary - 3.6.1 at the time of writing). This will begin the download of the ‘.exe’ installation file. When the download has completed double click on the R executable file and follow the on-screen instructions. Full installation instructions can be found at the CRAN website. 1.1.2 Mac users For Mac users select the ‘Download R for (Mac) OS X’ link. The binary can be downloaded by selecting the ‘R-3.X.X.pkg’ (R-3.6.1.pkg at the time of writing). Once downloaded, double click on the file icon and follow the on-screen instructions to guide you through the necessary steps. See the ‘R for Mac OS X FAQ’ for further information on installation. 1.1.3 Linux users For Linux users, the installation method will depend on which flavour of linux you are using. There are reasonably comprehensive instruction here for Debian, Redhat, Suse and Ubuntu. In most cases you can just use your OS package manager to install R from the official repository. On Ubuntu fire up a shell (Terminal) and use (you will need root permission to do this): sudo apt update sudo apt install r-base r-base-dev which will install base R and also the development version of base R (you only need this if you want to compile R packages from source but it doesn’t hurt to have it). If you receive an error after running the code above you may need to add a ‘source.list’ entry to your etc/apt/sources.list file. To do this open the /etc/apt/sources.list file in your favourite text editor (gedit, vim, nano etc) and add the following line (you will need root permission to do this): deb https://cloud.r-project.org/bin/linux/ubuntu disco-cran35/ This is the source.list for the latest version of Ubuntu (19.04 Disco Dingoat the time of writing). If you’re using an earlier version of Ubuntu then replace the source.list entry to the one which corresponds to the version of Ubuntu you are using (see here for an up to date list). Once you have done this then re-run the apt commands above and you should be good to go. 1.1.4 Testing R Whichever operating system you’re using, once you have installed R you need to check its working properly. The easiest way to do this is to start R by double clicking on the R icon (Windows or Mac) or by typing R into the console (Linux). You should see the R console and you should be able to type R commands into the console. Try typing the following R code and then press enter (don’t worry of you don’t understand this - we’re just checking if R works) A plot of the numbers 1 to 10 on both the x and y axes should appear. If you see this, you’re good to go. If not then we suggest you make a note of any errors produced and then use Google to troubleshoot). plot(1:10) Figure 1.1: plot to test R installation "],
["installing-rstudio.html", "1.2 Installing RStudio", " 1.2 Installing RStudio Whilst its eminently possible to just use the base installation of R (many people do), we will be using a popular Integrated Development Environment (IDE) called RStudio. RStudio can be thought of as an add-on to R which provides a more user-friendly interface, incorporating the R console, script editor and other useful functionality (like R markdown and Git Hub integration). You can find more information about RStudio here. RStudio is freely available for Windows, Mac and Linux operating systems and can be downloaded from the RStudio site. You should select the ‘RStudio Desktop’ version. Note: you must install R before you install RStudio (see previous section for details). 1.2.1 Windows and Mac users For Windows and Mac users you should be presented with the appropriate link for downloading. Click on this link and once downloaded run the installer and follow the instructions. If you don’t see the link then scroll down to the ‘All Installers’ section and choose the link manually. 1.2.2 Linux users For linux users** scroll down to the ‘All Installers’ section and choose the appropriate link to download the binary for your Linux operating system. RStudio for Ubuntu (and Debian) is available as a *.deb package. The easiest way to install deb files on Ubuntu is by using the gdebi command. If gdebi is not available on your system you can install it by using the following command in the Terminal (you will need root permission to do this) sudo apt update sudo apt install gdebi-core To install the *.deb file navigate to where you downloaded the file and then enter the following command with root permission sudo gdebi rstudio-xenial-1.2.5XXX-amd64.deb where ‘-1.2.5XXX’ is the current version for Ubuntu (rstudio-xenial-1.2.5019-amd64.deb at the time of writing). You can then start RStudio from the console by simply typing rstudio or you can create a shortcut on your Desktop for easy startup. 1.2.3 Testing RStudio Once installed, you can check everything is working by starting up RStudio (you don’t need to start R as well, just RStudio). You should see something like the image below (there might only be 3 windows when you first start RStudio, don’t worry, we’ll get to this in a bit). Figure 1.2: RStudio on Mac OS X "],
["rstudio-orient.html", "1.3 RStudio orientation", " 1.3 RStudio orientation When you open R studio for the first time you should see the following layout: The large window (aka pane) on the left is the Console window. The window on the top right is the Environment / History / Files pane and the bottom left window is the Plots / Help / Viewer window. We will discuss each of these panes in turn below. You can customise the location of each pane by clicking on the ‘Tools’ menu then selecting Global Options –&gt; Pane Layout. You can resize the panes by clicking and dragging the middle of the window borders in the direction you want. There are a plethora of other ways to [customise RStudio][rstudio-customise]. 1.3.1 Console The console is the workhorse of R. This is where R evaluates all the code you write and stores all the objects (data for example) you create. You can type R code directly into the console at the command line prompt, &gt;. For example, if you type 2 + 2 into the console you should obtain the answer 4 (reassuringly). Don’t worry about the [1] at the start of the line for now. However, once you start writing more R code this becomes rather cumbersome. Instead of typing R code directly into the console a better approach is to create an R script. An R script is just a plain text file with a .R file extension which contains your lines of R code. These lines of code are then sourced into the R console line by line. To create a new R script click on the ‘File’ menu then select New File –&gt; R Script. Notice that you have a new window (called the Source pane) in the top left of RStudio and the console is now in the bottom left position. The new window is a script editor and where you will write your code. To source your code from your script editor to the console simply place your cursor on the line of code and then click on the ‘Run’ button in the top right of the script editor pane. You should see the result in the console window. If clicking on the ‘Run’ button starts to become tiresome you can use the keyboard shortcut ‘ctrl + enter’ (on Windows and Linux) or ‘cmd + enter’ (on Mac). You can save your R scripts as a .R file by selecting the ‘File’ menu and clicking on save. Notice that the file name in the tab will turn red to remind you that you have unsaved changes. To open your R script in RStudio select the ‘File’ menu and then ‘Open File…’. Finally, its worth noting that although R scripts are saved with a .R extension they are actually just plain text files which can be opened with any text editor. 1.3.2 Environment / History / Files The Environment / History / Files window shows you lots of useful information. You can access each component by clicking on the appropriate tab in the pane. The ‘Environment’ tab displays all the objects you have created in the current (global) environment. These objects can be things like data you have imported or functions you have written. Objects can be displayed as a List or in Grid format by selecting your choice from the drop down button on the top right of the window. If you’re in the Grid format you can remove objects from the environment by placing a tick in the empty box next to the object name and then click on the broom icon. There’s also an ‘Import Dataset’ button which will import data saved in a variety of file formats. However, we would suggest that you don’t use this approach to import your data as it’s not reproducible and therefore not robust (see Chapter 3 for more details). The ‘History’ tab simply contains a list of all the commands you have entered into the R console. You can search back through your history for the line of code you have forgotten, send selected code back to the console or Source window. We usually never use this as we always refer back to our R script. The ‘Files’ tab lists all external files and directories in the current working directory on your computer. It works like file explorer (Windows) or Finder (Mac). You can open, copy, rename, move and delete files listed in the window. 1.3.3 Plots / Help / Viewer The ‘Plots’ tab is where all the plots you create in R are displayed (unless you tell R otherwise). You can ‘zoom’ into the plots to make them larger and scroll back through previously created plots using the arrow buttons. There is also the option of exporting plots to an external file using the ‘Export’ drop down menu. Plots can be exported in various file formats such as jpeg, png, pdf, tiff or copied to the clipboard (although you are probably better off using the appropriate R functions to do this - see Chapter 4 for more details). The ‘Help’ tab displays the R help documentation for any function. We will go over how to view the help files and how to search for help in Chapter 2. The ‘Viewer’ tab displays local web content such as web graphics generated by some packages. "],
["alternatives-to-rstudio.html", "1.4 Alternatives to RStudio", " 1.4 Alternatives to RStudio Although RStudio is becoming increasingly popular it might not be the best choice for everyone and you certainly don’t have to use it to use R effectively. Rather than using an ‘all in one’ IDE many people choose to use R and a separate script editor to write and execute R code. If you’re not familiar with what a script editor is, you can think of it as a bit like a word processor but specifically designed for writing code. Happily, there are many script editors freely available so feel free to download and experiment until you find one you like. Some script editors are only available for certain operating systems and not all are specific to R. Suggestions for script editors are: For windows users Tinn-R Atom Notepad++ For Mac users TextMate Atom MacVim For Linux users gedit (comes with Ubuntu already) Atom vim/nano (console based editors) Which one you choose is up to you. One of the great things about R is that YOU get to choose how you want to use R "],
["r-packages.html", "1.5 R packages", " 1.5 R packages The base installation of R comes with many useful packages as standard. These packages will contain many of the functions you will use on a daily basis. However, as you start using R for more diverse projects (and as your own use of R evolves) you will find that there comes a time when you will need to extend R’s capabilities. Happily, many thousands of R users have developed useful code and shared this code as installable packages. You can think of a package as a collection of functions, data and help files collated into a well defined standard structure which you can download and install in R. These packages can be downloaded from a variety of sources but the most popular are CRAN, Bioconductor and GitHub. Currently, CRAN hosts over 15000 packages and is the official repository for user contributed R packages. Bioconductor provides open source software oriented towards bioinformatics and hosts over 1800 R packages. GitHub is a website that hosts git repositories for all sorts of software and projects (not just R). Often, cutting edge development versions of R packages are hosted on GitHub so if you need all the new bells and whistles then this may be an option. However, a potential downside of using the development version of an R package is that it might not be as stable as the version hosted on CRAN (it’s in development!) and updating packages won’t be automatic. 1.5.1 CRAN packages To install a package from CRAN you can use the install.packages() function. For example if you want to install the devtools package enter the following code into the console window of RStudio (note: you will need a working internet connection to do this) install.packages(&#39;devtools&#39;, dependencies = TRUE) You may be asked to select a CRAN mirror, just select ‘0-cloud’ or a mirror near to your location. The dependencies = TRUE argument ensures that additional packages that are required will also be installed. It’s good practice to occasionally update your previously installed packages to get access to new functionality and bug fixes. To update CRAN packages you can use the update.packages() function (you will need a working internet connection for this) update.packages(ask = FALSE) The ask = FALSE argument avoids having to confirm every package download which can be a pain if you have many packages installed. 1.5.2 Bioconductor packages To install packages from Bioconductor the process is a little different. You first need to install the BiocManager package. You only need to do this once unless you subsequently reinstall or upgrade R install.packages(&#39;BiocManager&#39;, dependencies = TRUE) Once the BiocManager package has been installed you can either install all of the ‘core’ Bioconductor packages with BiocManager::install() or install specific packages such as the ‘GenomicRanges’ and ‘edgeR’ packages BiocManager::install(c(&quot;GenomicRanges&quot;, &quot;edgeR&quot;)) To update Bioconductor packages just use the BiocManager::install() function again BiocManager::install(ask = FALSE) Again, you can use the ask = FALSE argument to avoid having to confirm every package download. 1.5.3 GitHub packages There are multiple options for installing packages hosted on GitHub. Perhaps the most common method is to use the install_github() function from the devtools package (you installed this package previously). Before you use the function you will need to know the GitHub username of the repository owner and also the name of the repository. For example, the development version of dplyr from Hadley Wickham is hosted on the tidyverse GitHub account and has the repository name ‘dplyr’ (just Google ‘github dplyr’). To install this version form GitHub use devtools::install_github(&#39;tidyverse/dplyr&#39;) The safest way (that we know of) to update a package installed from GitHub is to just reinstall it using the above command. 1.5.4 Using packages Once you have installed a package onto your computer it is not immediately available for you to use. To use a package you first need to load the package by using the library() function. For example, to load the devtools package you previously installed library(devtools) The library() function will also load any additional packages required and may print out additional package information. It is important to realise that every time you start a new R session (or restore a previously saved session) you need to load the packages you will be using. We tend to put all our library() statements required for our analysis near the top of our R scripts to make them easily accessible and easy to add to as our code develops. If you try to use a function without first loading the relevant R package you will receive an error message that R could not find the function. For example, if you try to use the install_gitgub() function without loading the devtools package first you will receive the following error install_github(&#39;tidyverse/dplyr&#39;) # Error in install_github(&quot;tidyverse/dplyr&quot;) : # could not find function &quot;install_github&quot; Sometimes it can be useful to use a function without first using the library() function. If, for example, you will only be using one or two functions in your script and don’t want to load all of the other functions in a package then you can access the function directly by specifying the package name followed by two colons and then the function name devtools::install_github(&#39;tidyverse/dplyr&#39;) This is how we were able to use the install() and install_github() functions above without first loading the packages BiocManager and devtools. Most of the time we recommend using the library() function. "],
["writing-r-code.html", "1.6 Writing R code", " 1.6 Writing R code A quick note or two about writing R code and creating R scripts. Unless you’re doing something really quick and dirty we suggest that you always write your R code as an R script. R scripts are what make R so useful. Not only do you have a complete record of your analysis, from data manipulation, visualisation and statistical analysis, you can also share this code (and data) with friends, colleagues and importantly when you submit and publish your research to a journal. With this in mind, make sure you include in your R script all the information required to make your work reproducible (author names, dates, sampling design etc). This information could be included as a series of comments # or, even better, as code incorporating commentary into an R markdown document. Here is an example of including meta-information at the start of an R script # Title: Time series analysis of snouters # Purpose : This script performs a time series analyses on snouter count data. # Data consists of counts of snouter species collected from 18 islands # in the Hy-yi-yi archipelago between 1950 and 1957. # For details of snouter biology see: # https://en.wikipedia.org/wiki/Rhinogradentia # Project number: #007 # Data file: &#39;/Users/Another/snouter_analysis/snouter_pop.txt&#39; # Author: A. Nother # Contact details: a.nother@uir.ac.uk # Date script created: Mon Dec 2 16:06:44 2019 ------------------------------ # Date script last modified: Thu Dec 12 16:07:12 2019 ---------------------- This is just one example and there are no hard and fast rules so feel free to develop a system that works for you. One really useful shortcut in RStudio is to automatically include a time and date stamp in your R script. To do this, write ts where you want to insert your time stamp and then press the ‘shift + tab’ keys. RStudio will magically convert ts into the current date and time and also automatically comment out this line with a #. How you write your code is more or less up to you although your goal should be to make it as easy to read as possible (for you and others). Whilst there are no rules (and no code police), we encourage you to get into the habit of writing readable R code by adopting a particular style. We suggest that you follow Google’s R style guide whenever possible. This style guide will help you decide where to use spaces, how to indent code and how to use square [ ] and curly { } brackets amongst other things. If all that sounds like too much hard work you can install the styler package which includes an RStudio add-in to allow you to interactively restyle selected code (or entire files and projects) with the click of your mouse. You can find more information about the styler package including how to install here. Once installed, you can highlight the code you want to restyle, click on the ‘Addins’ button at the top of RStudio and select the ‘Style Selection’ option. Here is an example of poorly formatted R code Now highlight the code and use the styler package to reformat To produce some nicely formatted code "],
["basics-r.html", "Chapter 2 Some R Basics", " Chapter 2 Some R Basics content to follow "],
["data-r.html", "Chapter 3 Data in R", " Chapter 3 Data in R content to follow "],
["graphics-r.html", "Chapter 4 Graphics in R", " Chapter 4 Graphics in R For many people, one of their favourite uses of R is in making figures. These can either take the form of a quick dirty plot to allow you to get a feel for what’s going on in your dataset, or fancier/more complex figures to use in a publication or report. This process is often as close as many analysts/scientists get to having a professional creative side (at least that’s true for me), and it’s something which those folks take great pride in. As stated in the introduction, one of the many reasons for the rise in the popularity of R is due to its ability to produce publication standard figures (as well as those quick and dirty figures - which are the type you and I and everyone else will produce most of). Not only can R users make figures well suited for publication, but producing figures in R allows for lots of customisation, in turn allowing users to create their own particular styles and brands of figures (well beyond the beyond cookie-cutter styles in more traditional click and point programs). Because of this inherent flexibility when producing figures, the data visualisation side of R and supporting packages has grown substantially over the years. In this chapter, we will focus on creating figures through using a specialised package called ggplot2. Before we get going with making some plots of the gg variety, how about a quick little history of one of the most commonly used packages in R? ggplot2 was based on a book called Grammar of Graphics (hence the gg in ggplot2) by Leland Wilkinson yours for only £100 or so. But before you spend £100 see here for an interesting summary of Wilkinson’s book. Briefly, Wilkinson’s idea (one of them anyway) in grammar of graphics was that figures can be broken down into constituent parts, such as layers (more on this later). While Wilkinson would eventually go on to become vice-president of SPSS, his (and his co-author’s) ideas would, never-the-less, make their way into R via ggplot2. In 2007 ggplot2was officially released by Hadley Wickham. By 2017 the package was said to have been downloaded 10,000,000 times. ggplot2 now has many secondary packages that use it either as a foundation for expanding on or for interfacing with (some statistical packages now have accompanying ggplot2 interfaces for producing figures). It is important to note here that ggplot2 is not required to make “fancy” figures. If you’d prefer to use base R then go ahead. Exactly equivalent figures are possible in base R. The difference betweenggplot2 and base is to do with how you get to the end product rather than any differences in the end product itself. This is, never-the-less, a common belief almost certainly due to the fact that making a moderately attractive figure is easier to do with ggplot2 as many decisions are made for the user, without you necessarily even knowing that a decision was ever made! With that in mind, let’s get started making some figures. "],
["beginning-at-the-end.html", "4.1 Beginning at the end", " 4.1 Beginning at the end The approach I’ll use in this chapter will be to start off by showing you a figure which I reckon is at a standard that you could use in a poster or presentation. Using that as the aim, we will then work towards it step-by-step. You should not view this final figure as any sort of holy grail. For instance, you would be very unlikely to use this in a publication (you’d be much more likely to use some results of your hard earned-analysis). Regardless, this “final figure” is, and will only ever be, a reflection of what my personal preferences are. As with anything subjective, you may well disagree, and to some extent I hope you do. Much better that we all have slightly (or grossly) different views on what a good figure is - otherwise we may as well go back to using cookie-cutter figures. So what is the figure we’re going to make together? Before we go further, let’s take a second and talk about what this figure is literally showing. On the y axes of the four plots we have the area of the shoot and the x axes we have the weight of a flower. Each column shows the two treatments of the dataset (whether the tip of the flower was cut or not) and the two rows show which block of the greenhouse the plants were grown in (block 1 and block 2). The thin dotted line shows the mean shoot area regardless of the weight of the flowers, the treatment or the block. For our purposes, we won’t worry about the biology here (though you should absolutely care deeply about that in your own data); all we care about here is that we are giving the audience lots of information in a relatively readable format. "],
["the-start-of-the-end.html", "4.2 The start of the end", " 4.2 The start of the end The first step in producing a ggplot() is the easiest! We just need to install and then load the package. Use the skills you learnt in Chapter 1.5 to install and load the package. Note that although I (and pretty much everyone) refer to the package as ggplot, it’s proper name is ggplot2. library(ggplot2) With that taken care of, let’s make our first ggplot()! 4.2.1 The purest of ggplots During the R course this book is based on, the students are asked at one point to shout out all of the functions they have either learnt in the course or heard of/used before. At this point in the course we have not touched on ggplot2, but one year a student shouted out ggplot(). When asked what the ggplot() function does, they said that it makes a ggplot. This makes complete and utter sense. So let’s make a ggplot now: ggplot() And here we have it. A fully formed, perfect ggplot. We may have a small issue though. Some puritan data visualisers/plotists/figurines make the claim that figures should include some form of information beyond a light grey background. As loathe as I am to agree with purists, I will do so here. We really should include some data. To do so, we need some data. We’ll keep using the flower dataset that you used in the earlier chapters. Let’s have a quick reminder of what the data looked like. str(flower) #&gt; &#39;data.frame&#39;: 96 obs. of 9 variables: #&gt; $ treat : Factor w/ 2 levels &quot;notip&quot;,&quot;tip&quot;: 2 2 2 2 2 2 2 2 2 2 ... #&gt; $ nitrogen : Factor w/ 3 levels &quot;high&quot;,&quot;low&quot;,&quot;medium&quot;: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ block : int 1 1 1 1 1 1 1 1 2 2 ... #&gt; $ height : num 7.5 10.7 11.2 10.4 10.4 9.8 6.9 9.4 10.4 12.3 ... #&gt; $ weight : num 7.62 12.14 12.76 8.78 13.58 ... #&gt; $ leafarea : num 11.7 14.1 7.1 11.9 14.5 12.2 13.2 14 10.5 16.1 ... #&gt; $ shootarea: num 31.9 46 66.7 20.3 26.9 72.7 43.1 28.5 57.8 36.9 ... #&gt; $ flowers : int 1 10 10 1 4 9 7 6 5 8 ... #&gt; $ nitrogen2: Factor w/ 3 levels &quot;high&quot;,&quot;medium&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... We know from the “final figure” that we want shootarea on the y axis and weight on the x axis. To do so in ggplot2 we need to make use of the aes() function and also fulfill the data = argument. aes is short for aesthetics, and it’s the function we use to specify what we want displayed in the figure. Let’s try it now: # Including aesthetics for x and y axes as well as specifying the dataset ggplot(aes(x = weight, y = shootarea), data = flower) That’s already much better. At least it’s no longer a blank grey canvas. We’ve now told ggplot2 what we want as our x and y axes as well as where to find that data. But what’s missing here is where we tell ggplot2 how to display that data. This is now the time to introduce you to “geoms” or geometric objects. Geoms are the way that ggplot2 displays information. For instance geom_point() tells ggplot2 that you want the information to be displayed as points (making scatterplots possible for example). Given that the “final figure” uses points, this is clearly the appropriate geom to use here. Before we can do that, we need to talk about the coding structure used by ggplot2. The analogy that I and many others use is to say that making a figure in ggplot2 is much like painting. What we’ve done in the above code is making our “canvas”. Now we are going to add sequential layers to that painting, increasing the complexity and detail over time. Each time we want to include a new layer we need to include a + at the end of the proceeding layer to tell R and ggplot2 that there are additional layers coming. Let’s add (+) a new geom now: ggplot(aes(x = weight, y = shootarea), data = flower) + # Adding a geom to display data geom_point() If what we wanted was a quick and dirty figure to get a grasp of the trend in the data we can stop here. We can see that shootarea looks like it’s increasing with weight in a linear fashion. So long as this answers the question we were asking from the data, we have a figure that is perfectly suited for personal use. Though for showing to other people we might want something a bit more developed. If we glance back to our “final figure” we can see that we have lines representing different nitrogen concentrations. We can include lines using a geom. If you have a quick look through the available geoms here (XXXinsert linkXXX), you might think that geom_line() would be appropriate. Let’s try it. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Adding geom_line geom_line() Not quite what we were going for. The problem that we have is that geom_line() is actually just playing join-the-dots. The geom we actually want to use is called geom_smooth(). We can fix that very easily just by changing “line” to “smooth”. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Changing to geom_smooth geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Better, but still not what we wanted. The challenge here is that drawing a line is actually somewhat complicated. The way this line was drawn was using a method called “LOESS” which gives something very close to a moving average; useful in some cases, less so in others [ggplot2 will use LOESS as default when you have &lt; 1000 observations]. Instead of a wiggly line, we want a nice simple straight line to be drawn using a method called “lm” (short for linear model - see Chapter 5 for more details). Try looking at the help file, using ?geom_smooth, to see what other options are available for the method = argument. While we’re at it, let’s get rid of the confidence interval ribbon around the line. I prefer to do this as I think it’s clearer to the audience that this isn’t a properly analysed line and to treat it as a visual aid only. We can do this at the same time by setting the se = argument (short for standard error) to FALSE. Let’s update the code to use a linear model without confidence intervals. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Specifying the method as lm and se to false geom_smooth(method = &quot;lm&quot;, se = FALSE) That’s exactly what we wanted, though it’s still not matching the “final figure”. We need geom_smooth() to draw lines for each level of nitrogen concentration. Getting ggplot2 to do that is pretty straightforward. We can use the colour = argument within aes() (remember whatever we include in aes() will be something displayed in the figure) to tell ggplot2 to draw a different coloured line depending on nitrogen concentration. An aside: ggplot2 was written with both UK English and American English in mind, so both colour and color spellings work in ggplot2. ggplot(aes(x = weight, y = shootarea), data = flower) + geom_point() + # Including colour argument in aes() geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = FALSE) We’re getting closer, especially since ggplot2 has automatically created a legend for us. At this point it’s a good time to talk about where to include information - whether to include it within a geom or in ggplot(). When we include information such as data = and aes() in ggplot() we are setting those as the default, universal values which all subsequent geoms use. Whereas if we were to include that information within a geom, only that geom would use that specific information. In this case, we can easily move the information around and get exactly the same figure. ggplot() + # Moved aes() and data into geoms geom_point(aes(x = weight, y = shootarea), data = flower) + geom_smooth(aes(x = weight, y = shootarea, colour = nitrogen), data = flower, method = &quot;lm&quot;, se = FALSE) Doing so we get exactly the same figure. This ability to move information around is surprisingly powerful. It can allow different geoms to display different (albeit similar) information (see more on this later). For this worked example, we’ll move the same information back to the universal ggplot(),but we’ll also move colour = nitrogen into ggplot() so that we can have the points coloured according to nitrogen concentration as well. # Moved colour = nitrogen into the universal ggplot() ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) This figure is now what I would consider to be the typical ggplot2 figure (once you know to look for it, you’ll see it everywhere). We have specified some information, with only a few lines of code at that, yet we have something that looks quite attractive. While it’s not yet the “final figure” it is perfectly fit for purpose. You have now created you’re first “pure” ggplot. Let’s keep going as we’re aiming for something a bit more “sophisticated”. 4.2.2 Wrapping grids Having made our “pure” ggplot, the next big obstacle we’re going to tackle is the grid like layout of the “final figure” where the single figure has been split according to treatment and block, with new figures made for each combination. ggplot2 includes options for determining the “facets” of a figure. We’ll start off by using facet_wrap() to show what this can do. For facet_wrap() to work we need to specify a formula for how the facets will be defined (see ?facet_wrap for more details and also for how to define facets without using a formula). You can read ~ treat as saying “according to treatment”. Let’s see how it works: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Splitting the single figure into multiple depending on treatment facet_wrap(~ treat) That’s pretty good, though we are missing the rows showing different blocks. Given that facet_wrap can use a formula, maybe we could simply include block in the formula? Remember that block refers to the region in the greenhouse where the plants were grown. Let’s try it and see what happens. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Adding &quot;block&quot; to formula facet_wrap(~ treat + block) Play around: Try messing around with the formula to see what happens. Try putting ~ treat + flowers or even ~ treat + block + flowers. The important thing to remember here is that facet_wrap will create a new figure for each value in a variable. So when you wrap using a continuous variable like flowers, it makes a plot for every number of flowers counted. Be aware of what it is you are doing, but never be scared to experiment. Mistakes are easily fixed in R - it’s not like a point and click figure maker where you’d have to go through all those clicks to get the same figure again. Made a mistake? Easy, change it back and rerun the code (see Chapter 8 for version control which takes this to the next level). This facet layout is almost exactly what we want. Almost. But not exactly. In this case we actually want to be using facet_grid(), an alternative to facet_wrap(), which should put us back on track to make the “final figure”. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Changing to facet_grid facet_grid(~ treat + block) That’s disappointing. It’s pretty much the same as what we had before and is no closer to the “final figure”. What we need to do to fix it is to rearrange our formula so that we say that block in relation to treatment (not in combination to). ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Rearranging formula facet_grid(block ~ treat) 4.2.3 Plotting multiple ggplots And we’re there. Although the styling is not the same as the “final figure” this is showing the exact same fundamental information. We can plot them side-by-side to see how they compare. To do so we will use an additional package called patchwork. Go ahead and install and load patchwork (see Chapter 1.5 if you need a refresher for how to do this). An important note: For those who have used base R to produce their figure and are used to using par(mfrow = c(2,2)) to plot up to four figures in two rows and two columns, be aware that this does not work for ggplot2 objects. Instead you will need to use either patchwork or alternative packages such as gridArrange or cowplot or covert the ggplot2 objects to grobs. We’ll need to go back to our previous code and do something clever. We can assign figures a name and then use that to call the figure whenever we run the name. For instance, I have assigned the “final figure” the name…. final_figure (I’m not a clever person). final_figure We’ll do the same with the figure we’ve created together: # Naming our figure object rbook_figure &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Now when the code is run, the figure won’t be presented. This will only happen when we run the name of the figure as code. Well use this at the same time as showing how patchwork works. An old headache when using ggplot2 was that it could be difficult to create a nested figure (different plots all part of the same figure). patchwork resolves this problem very elegantly and simply. We have two immediate and simple options with patchwork; figures on top of each other (operationalised with /) and figures side-by-side (operationalised with either + or |). Let’s try. # rbook_figure | final_figure Giving us a nested stacked figure. Play around: Try to create a side-by-side version of the above figure (hint: try the other operators). We can also assign nested patchwork figures a name and use this in turn to create labels for individuals figures. # nested_compare &lt;- rbook_figure + final_figure #nested_compare + # plot_annotation(tag_levels = &quot;A&quot;) 4.2.4 Make it your own While we have a great figure already that shows the data we want it to show, it uses all of the default stylistic options. While the default options are arguably good, they may not be what we want ourselves. Maybe we’re going to use this figure in a presentation and we want to make sure someone in the very back of the room can easily read the figure. Maybe we want to use our own colour scheme. Maybe we want to change the grey background to a nice bright neon pink. In essence, maybe we want to decide things for ourselves. This next section will go through how to customise the appearance of our figure. Let’s start with the easier stuff, namely changing the size of the points using the size = argument. Before we do, have a think about where we’d include the argument? Should it be in ggplot() or geom_point()? ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including size argument to change the size of the points geom_point(size = 2) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Straightforward, we changed the size from the default of size = 1 to a value that we decide for ourselves. What happens if you included size in ggplot() or within the aes() of geom_point()? If we wanted to change the shape of the points to reflect nitrogen concentrations, how do you think we’d do that? We’d use the shape = argument, but this time we need to include an aes() within geom_point() because we want to include specific information to be displayed on the figure. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including shape argument to change the shape of the points geom_point(aes(shape = nitrogen), size = 2) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) Try including shape = nitrogen without also including aes() and see what happens. We’re getting closer and closer to the “final figure”. Another thing we may want to be able to do is change the transparency of the points. While it’s not actually that crucial here (arguably it might not be a good idea), changing the transparency of points is really valuable when you have lots of data and big clusters of points can be hidden. Doing this is, again, surprisingly easy, accomplished using the alpha = argument. Again, ask yourself where you think the alpha = argument should be included. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + # Including alpha argument to change the transparency of the points geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) We can also include defined labels for the x and y axis. There are a couple of ways to do this, but my preferred way is the same as used in base R figures; using xlab() and ylab(). As we are going to be creating new layers and adding them onto the figure, we’ll need to convey this to ggplot2 using +. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + # Adding layers for x and y labels xlab(&quot;Weight of flower (g)&quot;) + ylab(&quot;Area of shoot (cm^2)&quot;) Great. Just as we wanted, though getting the “(cm^2)” to show the square as a superscript would be ideal. Here, we’re going to accomplish that using a function which is part of base R called bquote() which allows for special characters to be shown. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + # Using bquote to get mathematically correct formatting ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) Let’s now work on the legend title while also including a caption to warn people looking at the figure to treat the trend lines with caution. We’ll use a new layer called labs(), short for labels, which we could have also used for specifying the x and y labels (we didn’t only for demonstration purposes, but give it a shot). labs() is a fairly straightforward function. Have a look at the help file (using ?labs) to see which arguments are available. We’ll be using caption = for the caption, but notice that there isn’t an argument for legend =? That’s because the legend is in fact multiple pieces of information; one being colour and one being shape. So instead of legend = we’ll use colour = and shape =. Here’s how we do it: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + # Adding labels for shape, colour and a caption labs(shape = &quot;Nitrogen Concentration&quot;, colour = &quot;Nitrogen Concentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) Play around: Try removing colour = or shape = from labs() to see what happens. The resulting legends are why we need to specify both colour and shape (and call it the same thing). Now is a good time to introduce “backslash n”. This is a base R feature which can be thought of as pressing Return in a word processor. It tells R that a string should be continued on a new line. We can use that with “Nitrogen Concentration” so that the legend title becomes more compact. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + # Including \\n to split legend title over two lines labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) We can now move onto some more wholesale-stylistic choices using the much loved themes of ggplot2. 4.2.5 Setting the theme ggplot2 contains so called themes. Themes control the base style of a ggplot. Let’s play around with themes using some skills we’ve already learnt; assigning plots to objects and plotting multiple ggplots in a single figure to explore some theme options. We assign themes by creating a new layer with theme_X(). classic &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Classic theme theme_classic() bw &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Black and white theme theme_bw() minimal &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Minimal theme theme_minimal() light &lt;- ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Light theme theme_light() #(classic | bw) / # (minimal | light) In terms of finding a theme that most closely matches our “final figure”, it’s probably going to be theme_classic(). There are additional themes available to you, and even more available online. GGthemes is a package you can download to get even more theme options. The BBC even have their own ggplot2 theme called “BBplot” (though I personally don’t like it too much for scientific figures). Indeed, you can even make your own theme which is what we’ll work on next. To begin with, we’ll have a look to see how theme_classic() was coded. We can do that easily enough by just writing the function name without the paranethesis (brackets). theme_classic #&gt; function (base_size = 11, base_family = &quot;&quot;, base_line_size = base_size/22, #&gt; base_rect_size = base_size/22) #&gt; { #&gt; theme_bw(base_size = base_size, base_family = base_family, #&gt; base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% #&gt; theme(panel.border = element_blank(), panel.grid.major = element_blank(), #&gt; panel.grid.minor = element_blank(), axis.line = element_line(colour = &quot;black&quot;, #&gt; size = rel(1)), legend.key = element_blank(), #&gt; strip.background = element_rect(fill = &quot;white&quot;, colour = &quot;black&quot;, #&gt; size = rel(2)), complete = TRUE) #&gt; } #&gt; &lt;bytecode: 0x000000001b243968&gt; #&gt; &lt;environment: namespace:ggplot2&gt; Let’s use this code as the basis for our own theme and modify it according to our needs. We’ll call the theme, theme_rbook. Not all of the options will immediately make sense, but don’t worry about this too much for now. Just know that the settings we’re putting in place are: Font size for axis titles = 20 Font size for x axis text = 10 Font size for y axis text = 10 Font for caption = 10 and italics Background colour = white Background border = black Axis lines = black Strip colour (for facets) = black Strip text colour (for facets) = white Legend box colours = blank This is by no means an exhaustive list of features you can specify in your own theme, but this will get you started. Of course, there is no need to use a personalised theme as the pre-built options are perfectly suitable. theme_rbook &lt;- function(base_size = 20, base_family = &quot;&quot;, base_line_size = base_size/22, base_rect_size = base_size/22) { theme( axis.title = element_text(size = 20), axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), plot.caption = element_text(size = 10, face = &quot;italic&quot;), panel.background = element_rect(fill=&quot;white&quot;), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size=0.5), axis.line = element_line(size = 1, colour = &quot;black&quot;), strip.background =element_rect(fill = &quot;black&quot;), strip.text = element_text(colour = &quot;white&quot;), legend.key=element_blank() ) } theme_rbook() is now available for us to use just like any other theme. Let’s try remaking our figure using our new theme. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Updated theme to our theme_rbook theme_rbook() 4.2.6 Prettification We’ve pretty much got to our “final figure”. We just have a few final adjustments to make, and we’ll do so in order of difficulty. Let’s remind ourselves of what that “final figure” looked like. Remember, since I have previously stored the figure as final_figure I can just type that into the console and pull up the figure. final_figure Let’s begin the final push by including that dashed horizontal line at about 80 on our y axis. This represents the overall mean area of a shoot, regardless of weight of flower, nitrogen concentration, treatment, or block. To draw a horizontal line we use a geom called geom_hline(), and the most important thing we need to specify is the y intercept value (in this case being our mean area of a shoot). We can also change the type of line using the argument linetype = and also the colour (as we did before). Let’s see how it works. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Added a horizontal line using geom_hline geom_hline(aes(yintercept = mean(shootarea)), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() Notice how we included the function mean(shootarea) within the geom_hline() function? We could also do that externally to the ggplot2 code and get the same result. mean(flower$shootarea) #&gt; [1] 79.8 ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Manually entering mean value geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() Exactly the same figure but produced in a slightly different way (the point being that there are always multiple ways to get code to do what you want), which brings us ever closer to that “final figure”. Let’s tackle that “overall” nitrogen effect. This overall line is effectively the figure we produced much earlier when we learnt how to get a line drawn using a linear model. But we are already using geom_smooth(), surely we can’t use it again? This may shock and/or surprise you so please ensure you are seated. You can use geom_smooth() again. In fact you can use it as many times as you want. You can use any layer as many times as you want! Isn’t the world full of wonderful miracles? … Anyway, here’s the damn code… ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + # Adding a ***SECOND*** geom_smooth :O geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + theme_rbook() That’s great! But you should be asking yourself why that worked. Why when we specified the first geom_smooth() did it draw 3 lines, whereas the second time we used geom_smooth() it just drew a single line? The secret lies in a “conflict” (it isn’t actually a conflict but I’ll call it that here) between the colour specified in the universal ggplot() and the colour specified in the second geom_smooth(). Notice how in the second we’ve specifically told ggplot2 that the colour will be black, while prior to this it drew lines based on the number of groups (or colours) in nitrogen? In “overriding” the universal ggplot() with a geom specific argument we’re able to get ggplot2 to plot what we want. The only things left now are to change the colour and the shape of the points to something of our choosing and include the “overall” trend line in the legend. We’ll begin with the former; changing colour and shape to something we specifically want. When I first started using ggplot2 this was actually the thing which caused me most difficulty. I think the reason is, that to manually change the colours actually requires an additional layer, where I assumed this would be done in either the universal ggplot() or in a geom. Instead of doing this within the specific geom, we’ll use scale_colour_manual() as well as scale_shape_manual(). Doing it this way will allow us to do two things at once; change the shape and colour to our choosing, and assign labels for these (much like what we did with xlab() and ylab()). Doing so is not too complex but will require nesting a function within another function, using c() (see chapter XXX for a reminder on the concatenate function). Let’s see how we can do it: ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + # Setting colour and associated labels scale_colour_manual(values = c(&quot;violetred3&quot;, &quot;limegreen&quot;, &quot;purple4&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + # Setting shape and associated labels scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() To make sense of that code (or any code for that matter) try running it piece by piece. For instance in the above code, if we run c(\"violetred3\", \"limegreen\", \"purple4\") we’ll get a list of those strings. That list is then passed on to scale_colour_manual() as the colours we wish to use. Since we only have three nitrogen concentrations, it will use these three colours. Try including an additional colour in the list and see what happens (if you place the new colour at the end of the list, nothing will happen since it will use the first three colours of the list - try adding it to the start of the list). The same is true for scale_shape_manual(). But if you’re paying close attention you’ll notice that there’s a mistake with the figure now. What should be labelled “Low” is actually labelled “Medium” (the green points and line are our low nitrogen concentration, but ggplot2 is saying that it is purple). ggplot2 hasn’t made a mistake here. We have. Remember that code is purely logical (or a golem using R McElreath’s terminology). It will do explicitly what it is told to do, and in this case we have told it to call the labels High, Medium and Low. We could have just as easily told ggplot2 to call them Pretoria, Tokyo, and Copenhagen. The lesson here is to always be critical of what your outputs are. Never assume that you are omnipotent and will never make mistakes. Double check everything you do. So how do we fix this? We need to do a little data manipulation to rearrange our factors so that the order goes High, Medium, Low. Let’s do that: flower$nitrogen &lt;- factor(flower$nitrogen, levels = c(&quot;high&quot;, &quot;medium&quot;, &quot;low&quot;)) With that done, we can re-do our above code to get a correct figure. ggplot(aes(x = weight, y = shootarea, colour = nitrogen), data = flower) + geom_point(aes(shape = nitrogen), size = 2, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(method = &quot;lm&quot;, se = FALSE, linetype = 2, alpha = 0.6, colour = &quot;black&quot;) + facet_grid(block ~ treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + geom_hline(aes(yintercept = 79.8), size = 0.5, colour = &quot;black&quot;, linetype = 3) + scale_colour_manual(values = c(&quot;violetred3&quot;, &quot;limegreen&quot;, &quot;purple4&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + scale_shape_manual(values = c(15,17,19), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;)) + theme_rbook() Last stretch! The only thing we have left now is to include the “Overall” trend line in the legend. To do this we have to be a touch “hacky” and trick ggplot2 into including “Overall” in the legend. This is not strictly needed and possibly not always adviseable, but I do it to show that ggplot2 can be coerced to do what you want (at times). There are a couple of steps we will need to take. The first is to move colour = nitrogen to the relevant geom_smooth() (which is displaying the trend lines for nitrogen) and to geom_point(). Doing this maintains the figure as we currently have it, but is required for the following to work. The next step will be to include colour = \"Overall\" in the overall geom_smooth() but importantly within aes(). Remember that aes() defines everything we want to displayed on the figure. Doing so here will force “Overall” to appear in a new, isolated, legend. The final steps are then to include the relevant information in scale_colour_manual() and scale_shape_manual(). But why include it in scale_shape_manual() since we have no points strictly associated with the “Overall” line? The points only relate to nitrogen concentration, so why would we need a shape for something which we have no points to display? Try removing sections of the data to try and figure out why we did this. # Moved colour argument out of universal ggplot ggplot(aes(x = weight, y = shootarea), data = flower) + # Inserted colour argument here geom_point(aes(colour = nitrogen, shape = nitrogen), size = 2, alpha = 0.6) + # Included colour and shape = &quot;Overall&quot; geom_smooth(aes(colour = &quot;Overall&quot;, shape = &quot;Overall&quot;), method = &quot;lm&quot;, se = F, linetype = 2, alpha = 0.6) + # Inserted colour argument here geom_smooth(aes(colour = nitrogen), method = &quot;lm&quot;, se = F, size = 1.2) + facet_grid(block~treat) + xlab(&quot;Weight of flower (g)&quot;) + ylab(bquote(&quot;Area of shoot&quot;~(cm^2))) + geom_hline(aes(yintercept = 79.7833), size = 0.5, colour = &quot;black&quot;, linetype = 3) + labs(shape = &quot;Nitrogen\\nConcentration&quot;, colour = &quot;Nitrogen\\nConcentration&quot;, caption = &quot;Lines are only to suggest trends&quot;) + # Included value and label for Overall line scale_colour_manual(values = c(&quot;violetred3&quot;, &quot;limegreen&quot;, &quot;purple4&quot;, &quot;black&quot;), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;Overall&quot;)) + # Included value and label for Overall line scale_shape_manual(values = c(15,17,19,21), labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;Overall&quot;)) + theme_rbook() #&gt; Warning: Ignoring unknown aesthetics: shape And we’ve done it! Our final figure matches the “final figure” exactly. While absolutely not an exhaustive list of what you can do with ggplot2, this will hopefully help when you’re making your own from scratch or copying ggplots made by other people (in which case hopefully this will help you understand what they’ve done). To round off this chapter, I will take you on a whistle-stop tour of some of the common types of plots you can make in the aptly named Beastiary section (which is totally different from a Bestiary). "],
["a-ggplot-beastiary.html", "4.3 A ggplot Beastiary", " 4.3 A ggplot Beastiary What follows is a quick run through of example ggplots. These will predominantly be done by changing the geoms used, but there will be additional slight tweaks which I’ll highlight. 4.3.1 Density plot Below is a density plot which is much like a histogram. The x axis shows observations of given numbers of flowers, while the y axis is the density of observations (roughly equivalent to number of rows with that many flowers). Each density is coloured according to nitrogen concentration, though note that we’re using fill = instead of colour =. Try using colour instead to see what happens. Notice that we haven’t used data = flowers here and instead just used flowers? When an object is not assigned with an argument, ggplot2 will assume that it is the dataset. We’re using that here, but I actually prefer to explicitly state what arguments are being fulfilled in my own work. ggplot(flower) + geom_density(aes(x = flowers, fill = nitrogen), alpha = 0.5) + labs(y = &quot;Density&quot;, x = &quot;Number of Flowers&quot;, fill = &quot;Nitrogen\\nConcentration&quot;) + scale_fill_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;steelblue4&quot;, &quot;orangered4&quot;, &quot;black&quot;)) + theme_rbook() 4.3.2 Histogram Next is a histogram (a much more traditional version of a density plot). There are a couple of things to take note of here. The first is that flower$block is numeric and not a factor. We can correct that here fairly easily using the factor() function to convert it from numeric to factor (though ideally we’d have done this before - see Chapter 3). The other thing to take note of is that I’ve specified bins = 20. The number of bins control how many times the y-axis is broken up to show the data. Try increasing and decreasing to see the effect. ggplot(flower) + geom_histogram(aes(x = flowers, fill = factor(block)), colour = &quot;black&quot;, bins = 20) + labs(y = &quot;Count&quot;, x = &quot;Number of Flowers&quot;, fill = &quot;Greenhouse\\nBlock&quot;) + scale_fill_manual(labels = c(&quot;1&quot;, &quot;2&quot;), values = c(&quot;steelblue4&quot;, &quot;firebrick4&quot;)) + theme_rbook() 4.3.3 Boxplot Boxplots are a classic way to show to spread of data, and they’re easy to make in ggplot2. The dark line in the middle of the box shows the median, the boxes show the 25th and 75th percentiles (which is different from the base R boxplot()), and the whiskers show 1.5 times the inter-quartile range (i.e. the distance between between the first and third quartiles). We can also make the boxes notched using the argument notch = TRUE. Notches extend (1.58 times the inter-quartile range) / square root of the number of observations. If notches do no overlap, it suggest (but only suggests) there may be a significant difference between groups. ggplot(flower) + geom_boxplot(aes(y = flowers, x = nitrogen), notch = TRUE) + labs(y = &quot;Number of Flowers&quot;, x = &quot;Nitrogen Concentration&quot;) + theme_rbook() 4.3.4 Violin plots Violin plots are an increasingly popular alternative to boxplots. They display much of the same information, as well as showing a version of the density plot above (imagine each violin plot, cut in half vertically, showing the overall distribution of the data). In the plot below the figure is slightly more complex than those above and so deserves some explanation. Within geom_violin() we’ve included draw_quantiles = where we’ve specified we want quantile lines drawn at the 25, 50 and 75 quantiles (using the c() function). In combination with geom_violin() we’ve also included geom_jitter(). geom_jitter() is similar to geom_point() but induces random spread of the points, often helpful when points would otherwise be clustered. Within geom_jitter() we’ve also set height = 0, and width = 0.1 which specifies how much to jitter the points in a given dimension (here essentially telling ggplot2 not to jitter by height, and only to jitter width by a small amount). Finally, I’m also using this plot to show scale_y_log10. Hopefully this is largely self-explanatory (it converts the y-axis to the log10 scale). There are additional scaling options for axis (for instance scale_y_sqrt()). ggplot(flower) + geom_violin(aes(y = flowers, x = nitrogen, fill = nitrogen), draw_quantiles = c(0.25, 0.5, 0.75), alpha = 0.4) + geom_jitter(aes(y = flowers, x = nitrogen, colour = nitrogen), height = 0, width = 0.1) + scale_fill_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;darkorchid4&quot;, &quot;darkorchid2&quot;, &quot;darkorchid1&quot;)) + scale_colour_manual(labels = c(&quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;), values = c(&quot;darkorchid4&quot;, &quot;darkorchid2&quot;, &quot;darkorchid1&quot;)) + labs(y = &quot;Number of Flowers&quot;, x = &quot;Nitrogen Concentration&quot;) + scale_y_log10() + theme_rbook() "],
["stats-r.html", "Chapter 5 Simple Statistics in R", " Chapter 5 Simple Statistics in R content to follow "],
["prog-r.html", "Chapter 6 Programming in R", " Chapter 6 Programming in R content to follow Ana add to this "],
["rmarkdown-r.html", "Chapter 7 Reproducible reports", " Chapter 7 Reproducible reports "],
["github-r.html", "Chapter 8 Version control with Git and GitHub", " Chapter 8 Version control with Git and GitHub "]
]
